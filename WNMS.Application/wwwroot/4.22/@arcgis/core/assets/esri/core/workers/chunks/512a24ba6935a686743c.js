"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[676],{55823:(e,t,s)=>{s.d(t,{a:()=>r});var n=s(76506),o=s(92847);function r(e,t,s){if(!s||!s.features||!s.hasZ)return;const r=(0,o.g)(s.geometryType,t,e.outSpatialReference);if(!(0,n.b)(r))for(const e of s.features)r(e.geometry)}},92847:(e,t,s)=>{s.d(t,{g:()=>i});var n=s(76506),o=s(53785),r=s(60947);function i(e,t,s){if((0,n.b)(t)||(0,n.b)(s)||s.vcsWkid||(0,r.e)(t,s))return null;const i=(0,o.b)(t)/(0,o.b)(s);if(1===i)return null;switch(e){case"point":case"esriGeometryPoint":return e=>{return s=i,void((t=e)&&null!=t.z&&(t.z*=s));var t,s};case"polyline":case"esriGeometryPolyline":return e=>function(e,t){if(e)for(const s of e.paths)for(const e of s)e.length>2&&(e[2]*=t)}(e,i);case"polygon":case"esriGeometryPolygon":return e=>function(e,t){if(e)for(const s of e.rings)for(const e of s)e.length>2&&(e[2]*=t)}(e,i);case"multipoint":case"esriGeometryMultipoint":return e=>function(e,t){if(e)for(const s of e.points)s.length>2&&(s[2]*=t)}(e,i);case"extent":case"esriGeometryExtent":return e=>function(e,t){e&&null!=e.zmin&&null!=e.zmax&&(e.zmin*=t,e.zmax*=t)}(e,i);default:return null}}},46987:(e,t,s)=>{s.d(t,{Z:()=>a});var n=s(22723),o=s(92143),r=s(50406),i=s(37453);s(76506),s(31450),s(71552),s(40642),s(60991),s(88762),s(32101);const l=o.L.getLogger("esri.core.workers.Connection");class a{constructor(){this._clients=new Array,this._clientPromises=new Array,this._clientIdx=0}destroy(){this.close()}get closed(){return!this._clients||!this._clients.length}open(e,t){return new Promise(((s,n)=>{let o=!0;const l=e=>{(0,r.k_)(t.signal),o&&(o=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length;for(let o=0;o<e.length;++o){const a=e[o];(0,r.y8)(a)?this._clientPromises[o]=a.then((e=>(this._clients[o]=new i.default(e,t),l(s),this._clients[o])),(()=>(l(n),null))):(this._clients[o]=new i.default(a,t),this._clientPromises[o]=Promise.resolve(this._clients[o]),l(s))}}))}broadcast(e,t,s){const n=new Array(this._clientPromises.length);for(let o=0;o<this._clientPromises.length;++o){const r=this._clientPromises[o];n[o]=r.then((n=>n.invoke(e,t,s)))}return n}close(){for(const e of this._clientPromises)e.then((e=>e.close()));this._clients.length=0,this._clientPromises.length=0}getAvailableClient(){let e;for(let t=0;t<this._clients.length;++t){const s=this._clients[t];if(s){if(!s.isBusy())return Promise.resolve(s)}else e=e||[],e.push(this._clientPromises[t])}return e?Promise.race(e):(this._clientIdx=(this._clientIdx+1)%this._clients.length,Promise.resolve(this._clients[this._clientIdx]))}invoke(e,t,s){let n=null;return Array.isArray(s)?(l.warn("invoke()","The transferList parameter is deprecated, use the options object instead"),n={transferList:s}):n=s,this.closed?Promise.reject(new Error("Connection closed")):this.getAvailableClient().then((s=>s.invoke(e,t,n)))}on(e,t){return Promise.all(this._clientPromises).then((()=>(0,n.h)(this._clients.map((s=>s.on(e,t))))))}openPorts(){return new Promise((e=>{const t=new Array(this._clientPromises.length);let s=t.length;for(let n=0;n<this._clientPromises.length;++n)this._clientPromises[n].then((o=>{t[n]=o.openPort(),0==--s&&e(t)}))}))}get test(){return{numClients:this._clients.length}}}},37453:(e,t,s)=>{s.r(t),s.d(t,{M:()=>a,default:()=>O,n:()=>u,p:()=>p,r:()=>d,t:()=>_});var n=s(88762),o=s(60991),r=s(50406),i=s(76506);s(32101),s(31450),s(71552),s(92143),s(40642);const l={statsWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(776),s.e(9461)]).then(s.bind(s,99461)).then((e=>e.f)),geometryEngineWorker:()=>Promise.all([s.e(3361),s.e(8258)]).then(s.bind(s,68258)),CSVSourceWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(776),s.e(1623),s.e(2274),s.e(873),s.e(673),s.e(7711),s.e(9884)]).then(s.bind(s,59884)),EdgeProcessingWorker:()=>s.e(8936).then(s.bind(s,8936)).then((e=>e.b)),ElevationSamplerWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(1623),s.e(4047),s.e(2795)]).then(s.bind(s,2795)),FeatureServiceSnappingSourceWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(776),s.e(8081),s.e(1623),s.e(2274),s.e(6971),s.e(873),s.e(673),s.e(7711),s.e(1151)]).then(s.bind(s,31151)),GeoJSONSourceWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(776),s.e(1623),s.e(2274),s.e(873),s.e(673),s.e(7711),s.e(3866),s.e(5181)]).then(s.bind(s,65181)),LercWorker:()=>s.e(8281).then(s.bind(s,38281)),MemorySourceWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(776),s.e(1623),s.e(2274),s.e(873),s.e(673),s.e(7711),s.e(3866),s.e(3900)]).then(s.bind(s,3900)),PBFDecoderWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(629)]).then(s.bind(s,629)),Pipeline:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(776),s.e(123),s.e(8081),s.e(1623),s.e(2274),s.e(6971),s.e(873),s.e(673),s.e(7663),s.e(7065)]).then(s.bind(s,47065)),PointCloudWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(1623),s.e(9151),s.e(5107)]).then(s.bind(s,5107)),RasterWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(1623),s.e(7195),s.e(9275)]).then(s.bind(s,59275)),SceneLayerWorker:()=>s.e(8931).then(s.bind(s,88931)),WFSSourceWorker:()=>Promise.all([s.e(6229),s.e(1801),s.e(243),s.e(776),s.e(1623),s.e(2274),s.e(873),s.e(673),s.e(7711),s.e(3866),s.e(1856),s.e(3018)]).then(s.bind(s,3018)),WorkerTileHandler:()=>Promise.all([s.e(5917),s.e(7497),s.e(3315)]).then(s.bind(s,53315))};var a,c;(c=a||(a={}))[c.HANDSHAKE=0]="HANDSHAKE",c[c.OPEN=1]="OPEN",c[c.OPENED=2]="OPENED",c[c.RESPONSE=3]="RESPONSE",c[c.INVOKE=4]="INVOKE",c[c.ABORT=5]="ABORT",c[c.CLOSE=6]="CLOSE",c[c.OPEN_PORT=7]="OPEN_PORT",c[c.ON=8]="ON";let h=0;function u(){return h++}function _(e){return e?"string"==typeof e?JSON.stringify({name:"message",message:e}):e.toJSON?JSON.stringify(e):JSON.stringify({name:e.name,message:e.message,details:e.details||{stack:e.stack}}):null}function p(e,t,s,n){if(t.type===a.OPEN_PORT)return void e.postMessage(t,[t.port]);if(t.type!==a.INVOKE&&t.type!==a.RESPONSE)return void e.postMessage(t);let o;var r;(r=s)&&"object"==typeof r&&("result"in r||"transferList"in r)?(o=g(s.transferList),t.data=s.result):(o=g(n),t.data=s),o?e.postMessage(t,o):e.postMessage(t)}function d(e){if(!e)return null;const t=e.data;return t?"string"==typeof t?JSON.parse(t):t:null}function g(e){if(!e||!e.length)return null;if((0,i.h)("esri-workers-arraybuffer-transfer"))return e;const t=e.filter((e=>{return!((t=e)instanceof ArrayBuffer||t&&t.constructor&&"ArrayBuffer"===t.constructor.name);var t}));return t.length?t:null}const{CLOSE:m,ABORT:f,INVOKE:b,RESPONSE:P,OPEN_PORT:v,ON:y}=a;class k{constructor(e){this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._invoke=e,this._timer=null,this._process=this._process.bind(this)}push(e){e.type===a.ABORT?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))}clear(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null}_process(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0}}class O{constructor(e,t){this._port=e,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new k((e=>this._onInvokeMessage(e))),this._client=t.client,this._onMessage=this._onMessage.bind(this),this._channel=t.channel,this._schedule=t.schedule,this._port.addEventListener("message",this._onMessage),this._port.start()}static connect(e){const t=new MessageChannel;let s;s="function"==typeof e?new e:"default"in e&&"function"==typeof e.default?new e.default:e;const n=new O(t.port1,{channel:t,client:s});return"object"==typeof s&&"remoteClient"in s&&(s.remoteClient=n),O.clients.set(n,s),t.port2}static loadWorker(e){const t=l[e];return t?t():Promise.resolve(null)}close(){this._post({type:m}),this._close()}isBusy(){return this._outJobs.size>0}invoke(e,t,s){const n=s&&s.signal,i=s&&s.transferList;if(!this._port)return Promise.reject(new o.Z("worker:port-closed",`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:t}));const l=u();return new Promise(((s,o)=>{const a=(0,r.$F)(n,(()=>{var e;const t=this._outJobs.get(l);t&&(this._outJobs.delete(l),null==(e=t.abortHandle)||e.remove(),this._post({type:f,jobId:l}),o((0,r.zE)()))})),c={resolve:s,reject:o,abortHandle:a,debugInfo:e};this._outJobs.set(l,c),this._post({type:b,jobId:l,methodName:e,abortable:null!=n},t,i)}))}on(e,t){const s=new MessageChannel;function n(e){t(e.data)}return this._port.postMessage({type:a.ON,eventType:e,port:s.port2},[s.port2]),s.port1.addEventListener("message",n),s.port1.start(),{remove(){s.port1.postMessage({type:a.CLOSE}),s.port1.close(),s.port1.removeEventListener("message",n)}}}openPort(){const e=new MessageChannel;return this._post({type:v,port:e.port2}),e.port1}_close(){this._channel&&(this._channel=null),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach((e=>{var t;null==(t=e.abortHandle)||t.remove(),e.reject((0,r.zE)(`Worker closing, aborting job calling '${e.debugInfo}'`))})),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=this._client=this._schedule=null}_onMessage(e){(0,i.i)(this._schedule)?this._schedule((()=>this._processMessage(e))):this._processMessage(e)}_processMessage(e){const t=d(e);if(t)switch(t.type){case P:this._onResponseMessage(t);break;case b:this._invokeQueue.push(t);break;case f:this._onAbortMessage(t);break;case m:this._onCloseMessage();break;case v:this._onOpenPortMessage(t);break;case y:this._onOnMessage(t)}}_onAbortMessage(e){const t=this._inJobs,s=e.jobId,n=t.get(s);this._invokeQueue.push(e),n&&(n.controller&&n.controller.abort(),t.delete(s))}_onCloseMessage(){const e=this._client;this._close(),e&&"destroy"in e&&O.clients.get(this)===e&&e.destroy(),O.clients.delete(this),e&&e.remoteClient&&(e.remoteClient=null)}_onInvokeMessage(e){const{methodName:t,jobId:s,data:n,abortable:o}=e,i=o?new AbortController:null,l=this._inJobs;let a,c=this._client,h=c[t];try{if(!h&&t&&-1!==t.indexOf(".")){const e=t.split(".");for(let t=0;t<e.length-1;t++)c=c[e[t]],h=c[e[t+1]]}if("function"!=typeof h)throw new TypeError(`${t} is not a function`);a=h.call(c,n,{client:this,signal:i?i.signal:null})}catch(e){return void this._post({type:P,jobId:s,error:_(e)})}(0,r.y8)(a)?(l.set(s,{controller:i,promise:a}),a.then((e=>{l.has(s)&&(l.delete(s),this._post({type:P,jobId:s},e))}),(e=>{l.has(s)&&(l.delete(s),(0,r.D_)(e)||this._post({type:P,jobId:s,error:_(e||{message:`Error encountered at method ${t}`})}))}))):this._post({type:P,jobId:s},a)}_onOpenPortMessage(e){new O(e.port,{client:this._client})}_onOnMessage(e){const{port:t}=e,s=this._client.on(e.eventType,(e=>{t.postMessage(e)})),n=(0,r.o)(e.port,"message",(e=>{d(e).type===a.CLOSE&&(n.remove(),s.remove(),t.close())}))}_onResponseMessage(e){var t;const{jobId:s,error:n,data:r}=e,i=this._outJobs;if(!i.has(s))return;const l=i.get(s);i.delete(s),null==(t=l.abortHandle)||t.remove(),n?l.reject(o.Z.fromJSON(JSON.parse(n))):l.resolve(r)}_post(e,t,s){return p(this._port,e,t,s)}}O.kernelInfo={revision:n.LB,version:n.i8,buildDate:n.rh},O.clients=new Map}}]);