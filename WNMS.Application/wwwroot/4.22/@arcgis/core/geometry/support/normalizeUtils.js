/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import t from"../../config.js";import e from"../../core/Error.js";import{L as s}from"../../chunks/Logger.js";import{b as n,i as o}from"../../core/lang.js";import r from"../Polygon.js";import i from"../Polyline.js";import{g as c,o as p,u as l,c as u}from"../../chunks/normalizeUtilsCommon.js";import{g as f}from"../SpatialReference.js";import{geographicToWebMercator as a,webMercatorToGeographic as m}from"./webMercatorUtils.js";import"../../geometry.js";import h from"../../request.js";import{urlToObject as g}from"../../core/urlUtils.js";import{getJsonType as y,fromJSON as j,getGeometryType as x}from"./jsonUtils.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/tslib.es6.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ensureType.js";import"../../chunks/metadata.js";import"../../chunks/handleUtils.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/writer.js";import"../Extent.js";import"../Geometry.js";import"../../chunks/JSONSupport.js";import"../../core/Accessor.js";import"../../chunks/deprecate.js";import"../../chunks/ArrayPool.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../core/promiseUtils.js";import"../../chunks/reader.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/Ellipsoid.js";import"../../chunks/extentUtils.js";import"../../chunks/zmUtils.js";import"../Multipoint.js";import"../../chunks/typeUtils.js";import"../../chunks/jsonMap.js";import"../../kernel.js";async function d(t,e,s){const n="string"==typeof t?g(t):t,o=e[0].spatialReference,r=y(e[0]),i={...s,query:{...n.query,f:"json",sr:o.wkid?o.wkid:JSON.stringify(o),geometries:JSON.stringify(k(e))}};return function(t,e,s){const n=x(e);return t.map((t=>{const e=n.fromJSON(t);return e.spatialReference=s,e}))}((await h(n.path+"/simplify",i)).data,r,o)}function k(t){return{geometryType:y(t[0]),geometries:t.map((t=>t.toJSON()))}}const w=s.getLogger("esri.geometry.support.normalizeUtils");function S(t){return"polyline"===t[0].type}function R(t){const e=[];let s=0,n=0;for(let o=0;o<t.length;o++){const r=t[o];let i=null;for(let t=0;t<r.length;t++)i=r[t],e.push(i),0===t?(s=i[0],n=s):(s=Math.min(s,i[0]),n=Math.max(n,i[0]));i&&e.push([(s+n)/2,0])}return e}function U(t,s){if(!(t instanceof i||t instanceof r)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw w.error(t),new e(t)}const n=c(t),o=[];for(const t of n){const e=[];o.push(e),e.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const o=t[n][0],r=t[n][1],i=t[n+1][0],c=t[n+1][1],p=Math.sqrt((i-o)*(i-o)+(c-r)*(c-r)),l=(c-r)/p,u=(i-o)/p,f=p/s;if(f>1){for(let t=1;t<=f-1;t++){const n=t*s,i=u*n+o,c=l*n+r;e.push([i,c])}const t=(p+Math.floor(f-1)*s)/2,n=u*t+o,i=l*t+r;e.push([n,i])}e.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new r({rings:o,spatialReference:t.spatialReference}):new i({paths:o,spatialReference:t.spatialReference})}function M(t,e,s){if(e){const e=U(t,1e6);t=m(e,!0)}return s&&(t=l(t,s)),t}function b(t,e,s){if(Array.isArray(t)){const n=t[0];if(n>e){const s=p(n,e);t[0]=n+s*(-2*e)}else if(n<s){const e=p(n,s);t[0]=n+e*(-2*s)}}else{const n=t.x;if(n>e){const s=p(n,e);t=t.clone().offset(s*(-2*e),0)}else if(n<s){const e=p(n,s);t=t.clone().offset(e*(-2*s),0)}}return t}async function N(e,s,m){var x;if(!Array.isArray(e))return N([e],s);const k=null!=(x=null==s?void 0:s.url)?x:t.geometryServiceUrl;let w,R,U,P,J,O,q,v,A=0;const L=[],z=[];for(const t of e)if(n(t))z.push(t);else if(w||(w=t.spatialReference,R=f(w),U=w.isWebMercator,O=U?102100:4326,P=u[O].maxX,J=u[O].minX,q=u[O].plus180Line,v=u[O].minus180Line),R)if("mesh"===t.type)z.push(t);else if("point"===t.type)z.push(b(t.clone(),P,J));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((t=>b(t,P,J))),z.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,R);z.push(e.rings?new r(e):e)}else if(t.extent){const e=t.extent,s=p(e.xmin,J)*(2*P);let n=0===s?t.clone():l(t.clone(),s);e.offset(s,0),e.intersects(q)&&e.xmax!==P?(A=e.xmax>A?e.xmax:A,n=M(n,U),L.push(n),z.push("cut")):e.intersects(v)&&e.xmin!==J?(A=e.xmax*(2*P)>A?e.xmax*(2*P):A,n=M(n,U,360),L.push(n),z.push("cut")):z.push(n)}else z.push(t.clone());else z.push(t);let I=p(A,P),T=-90;const E=I,X=new i;for(;I>0;){const t=360*I-180;X.addPath([[t,T],[t,-1*T]]),T*=-1,I--}if(L.length>0&&E>0){const t=await async function(t,e,s,n){const o="string"==typeof t?g(t):t,r=e[0].spatialReference,i={...n,query:{...o.query,f:"json",sr:JSON.stringify(r),target:JSON.stringify({geometryType:y(e[0]),geometries:e}),cutter:JSON.stringify(s)}},c=await h(o.path+"/cut",i),{cutIndexes:p,geometries:l=[]}=c.data;return{cutIndexes:p,geometries:l.map((t=>{const e=j(t);return e.spatialReference=r,e}))}}(k,L,X,m),s=function(t,e){let s=-1;for(let n=0;n<e.cutIndexes.length;n++){const o=e.cutIndexes[n],r=e.geometries[n],i=c(r);for(let t=0;t<i.length;t++){const e=i[t];e.some((s=>{if(s[0]<180)return!0;{let s=0;for(let t=0;t<e.length;t++){const n=e[t][0];s=n>s?n:s}s=Number(s.toFixed(9));const n=-360*p(s,180);for(let s=0;s<e.length;s++){const e=r.getPoint(t,s);r.setPoint(t,s,e.clone().offset(n,0))}return!0}}))}if(o===s){if("polygon"===t[0].type)for(const e of c(r))t[o]=t[o].addRing(e);else if(S(t))for(const e of c(r))t[o]=t[o].addPath(e)}else s=o,t[o]=r}return t}(L,t),n=[],r=[];for(let t=0;t<z.length;t++){const i=z[t];if("cut"!==i)r.push(i);else{const i=s.shift(),c=e[t];o(c)&&"polygon"===c.type&&c.rings&&c.rings.length>1&&i.rings.length>=c.rings.length?(n.push(i),r.push("simplify")):r.push(U?a(i):i)}}if(!n.length)return r;const i=await d(k,n,m),l=[];for(let t=0;t<r.length;t++){const e=r[t];"simplify"!==e?l.push(e):l.push(U?a(i.shift()):i.shift())}return l}const C=[];for(let t=0;t<z.length;t++){const e=z[t];if("cut"!==e)C.push(e);else{const t=L.shift();C.push(!0===U?a(t):t)}}return Promise.resolve(C)}function P(t){if(!t)return null;const e=t.extent;if(!e)return null;const s=t.spatialReference&&f(t.spatialReference);if(!s)return e;const[n,o]=s.valid,r=2*o,{width:i}=e;let c,{xmin:p,xmax:l}=e;if([p,l]=[l,p],"extent"===t.type||0===i||i<=o||i>r||p<n||l>o)return e;switch(t.type){case"polygon":if(!(t.rings.length>1))return e;c=R(t.rings);break;case"polyline":if(!(t.paths.length>1))return e;c=R(t.paths);break;case"multipoint":c=t.points}const u=e.clone();for(let t=0;t<c.length;t++){let e=c[t][0];e<0?(e+=o,l=Math.max(e,l)):(e-=o,p=Math.min(e,p))}return u.xmin=p,u.xmax=l,u.width<i?(u.xmin-=o,u.xmax-=o,u):e}function J(t,e){const s=f(e);if(s){const[e,n]=s.valid,o=n-e;if(t<e)for(;t<e;)t+=o;if(t>n)for(;t>n;)t-=o}return t}export{P as getDenormalizedExtent,N as normalizeCentralMeridian,J as normalizeMapX,U as straightLineDensify};
