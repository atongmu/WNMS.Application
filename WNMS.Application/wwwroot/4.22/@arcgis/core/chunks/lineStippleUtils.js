/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{o as t,b as e,i as s}from"../core/lang.js";import{g as n,a as r}from"./unitConversionUtils.js";import{L as i}from"./Logger.js";import{k as o,b as a}from"./ScreenSpacePass.js";import{l as h}from"./arcadeOnDemand.js";import{g as u}from"../core/Accessor.js";import{f}from"./mat4.js";import{c as d,I as l}from"./mat4f64.js";import{j as c}from"./mathUtils.js";import{c as m}from"./vec4f64.js";import{e as p}from"./mathUtils2.js";import{a as g}from"./geometryDataUtils.js";import{b as x,r as _}from"./utils14.js";const U=i.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function I(t){const e=t&&t.expression;if("string"==typeof e){const t=b(e);if(null!=t)return{cachedResult:t}}return null}async function E(t,e,s){const n=t&&t.expression;if("string"!=typeof n)return null;const r=b(n);if(null!=r)return{cachedResult:r};const i=await h(),o=i.arcadeUtils,a=o.createSyntaxTree(n);return o.dependsOnView(a)?(null!=s&&s.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:o.createFunction(a),context:o.createExecContext(null,{sr:e}),modules:i}}}function v(t,e,s){return t.arcadeUtils.createFeature(e.attributes,e.geometry,s)}function y(t,e){if(null!=t&&!R(t)){if(!e||!t.arcade)return void U.errorOncePerTick("Arcade support required but not provided");const s=e;s._geometry&&(s._geometry=o(s._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function O(t,e=!1){let s=t&&t.featureExpressionInfo;const n=s&&s.expression;return e||"0"===n||(s=null),s}const T={cachedResult:0};function R(t){return null!=t.cachedResult}function b(t){return"0"===t?0:null}class C{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(t){this._unit=t,this._metersPerElevationInfoUnit=n(t)}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(t){this._meterUnitOffset=t,this._renderUnitOffset=0}set offsetElevationInfoUnits(t){this._meterUnitOffset=t*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(t){this._renderUnitOffset+=t}geometryZWithOffset(t,e){const s=this.calculateOffsetRenderUnits(e);return null!=this.featureExpressionInfoContext?s:t+s}calculateOffsetRenderUnits(t){let e=this._meterUnitOffset;const s=this.featureExpressionInfoContext;return null!=s&&(e+=function(t){if(null!=t){if(R(t))return t.cachedResult;const e=t.arcade;let s=t.arcade.modules.arcadeUtils.executeFunction(e.func,e.context);return"number"!=typeof s&&(t.cachedResult=0,s=0),s}return 0}(s)*this._metersPerElevationInfoUnit),e/t.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=r(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=t(e.offset,0)}updateFeatureExpressionInfoContext(t,n,r){if(e(t))return void(this._featureExpressionInfoContext=null);const i=t&&t.arcade;var o;i&&s(n)&&s(r)?(this._featureExpressionInfoContext={cachedResult:(o=t).cachedResult,arcade:o.arcade?{func:o.arcade.func,context:o.arcade.modules.arcadeUtils.createExecContext(null,{sr:o.arcade.context.spatialReference}),modules:o.arcade.modules}:null},y(this._featureExpressionInfoContext,v(i.modules,n,r))):this._featureExpressionInfoContext=t}static fromElevationInfo(t){const e=new C;return s(t)&&e.setFromElevationInfo(t),e}}class S{constructor(t,e,s=null,n=null,r=u(),i=null,o=null,a=!1){this.data=t,this.material=e,this.layerUid=s,this.graphicUid=n,this.id=r,this.boundingInfo=i,this.calculateShaderTransformation=o,this.castShadow=a,this.boundingSphere=m(),this.instanceParameters={highlights:null,occludees:null,visible:!0},this._transformation=d(),this._shaderTransformationDirty=!0}get transformation(){return this._transformation}updateTransformation(t){t(this._transformation),this._shaderTransformationDirty=!0,this.computeBoundingSphere(this._transformation,this.boundingSphere)}shaderTransformationChanged(){this._shaderTransformationDirty=!0}computeBoundingSphere(t,s,n=p(t)){e(this.boundingInfo)||(c(s,this.boundingInfo.getCenter(),t),s[3]=this.boundingInfo.getBSRadius()*n)}get hasShaderTransformation(){return s(this.calculateShaderTransformation)}get primitiveType(){return this.data.primitiveType}getShaderTransformation(){return e(this.calculateShaderTransformation)?t(this.transformation,l):(this._shaderTransformationDirty&&(this._shaderTransformation||(this._shaderTransformation=d()),f(this._shaderTransformation,this.calculateShaderTransformation(t(this.transformation,l))),this._shaderTransformationDirty=!1),this._shaderTransformation)}computeAttachmentOrigin(t){if(this.material.computeAttachmentOrigin)return!!this.material.computeAttachmentOrigin(this,t)&&(s(this._transformation)&&c(t,t,this._transformation),!0);const e=this.indices.get("position"),n=this.vertexAttributes.get("position");return!!g(n,e,t)&&(s(this._transformation)&&c(t,t,this._transformation),!0)}get indices(){return this.data.indices}get vertexAttributes(){return this.data.vertexAttributes}addHighlight(){const t=new a(0),e=this.instanceParameters;return e.highlights=x(e.highlights,t),t}removeHighlight(t){const e=this.instanceParameters;e.highlights=_(e.highlights,t)}}const j={dash:[4,3],dot:[1,3],"long-dash":[8,3],"short-dash":[4,1],"short-dot":[1,1]},P={dash:j.dash,"dash-dot":[...j.dash,...j.dot],dot:j.dot,"long-dash":j["long-dash"],"long-dash-dot":[...j["long-dash"],...j.dot],"long-dash-dot-dot":[...j["long-dash"],...j.dot,...j.dot],none:null,"short-dash":j["short-dash"],"short-dash-dot":[...j["short-dash"],...j["short-dot"]],"short-dash-dot-dot":[...j["short-dash"],...j["short-dot"],...j["short-dot"]],"short-dot":j["short-dot"],solid:null};function A(t,e=2){return{pattern:[t,t],pixelRatio:e}}function w(t){return s(t)&&"style"===t.type?function(t,s=2){return e(t)?t:{pattern:t.slice(),pixelRatio:s}}(P[t.style],8):null}export{C as E,S as R,E as a,I as b,v as c,A as d,O as e,w as g,y as s,T as z};
