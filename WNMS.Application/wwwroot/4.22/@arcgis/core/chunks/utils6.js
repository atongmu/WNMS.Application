/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./ensureType.js";import{e as t}from"./enumeration.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import{a as n}from"./JSONSupport.js";import"./Logger.js";import"../geometry.js";import{r as s}from"./reader.js";import{w as i}from"./writer.js";import f from"../geometry/Point.js";import l from"../geometry/Extent.js";let a=class extends n{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};e([r()],a.prototype,"affectsPixelSize",null),e([r({json:{write:!0}})],a.prototype,"spatialReference",void 0),a=e([o("esri.layers.support.rasterTransforms.BaseRasterTransform")],a);const p=a;let c=class extends p{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(e){return"point"===(e=e.clone()).type?(e.x>180+this.tolerance&&(e.x-=360),e):(e.xmin>=180-this.tolerance?(e.xmax-=360,e.xmin-=360):e.xmax>180+this.tolerance&&(e.xmin=-180,e.xmax=180),e)}inverseTransform(e){return"point"===(e=e.clone()).type?(e.x<-this.tolerance&&(e.x+=360),e):(e.xmin<-this.tolerance&&(e.xmin+=360,e.xmax+=360),e)}};e([t({GCSShiftXform:"gcs-shift"})],c.prototype,"type",void 0),e([r()],c.prototype,"tolerance",void 0),c=e([o("esri.layers.support.rasterTransforms.GCSShiftTransform")],c);const u=c;let m=class extends p{constructor(){super(...arguments),this.type="identity"}};e([t({IdentityXform:"identity"})],m.prototype,"type",void 0),m=e([o("esri.layers.support.rasterTransforms.IdentityTransform")],m);const y=m;function h(e,r,t){const{x:o,y:n}=r;if(t<2){return{x:e[0]+o*e[2]+n*e[4],y:e[1]+o*e[3]+n*e[5]}}if(2===t){const r=o*o,t=n*n,s=o*n;return{x:e[0]+o*e[2]+n*e[4]+r*e[6]+s*e[8]+t*e[10],y:e[1]+o*e[3]+n*e[5]+r*e[7]+s*e[9]+t*e[11]}}const s=o*o,i=n*n,f=o*n,l=s*o,a=s*n,p=o*i,c=n*i;return{x:e[0]+o*e[2]+n*e[4]+s*e[6]+f*e[8]+i*e[10]+l*e[12]+a*e[14]+p*e[16]+c*e[18],y:e[1]+o*e[3]+n*e[5]+s*e[7]+f*e[9]+i*e[11]+l*e[13]+a*e[15]+p*e[17]+c*e[19]}}function x(e,r,t){const{xmin:o,ymin:n,xmax:s,ymax:i,spatialReference:f}=r;let a=[];if(t<2)a.push({x:o,y:i}),a.push({x:s,y:i}),a.push({x:o,y:n}),a.push({x:s,y:n});else{let e=10;for(let r=0;r<e;r++)a.push({x:o,y:n+(i-n)*r/(e-1)}),a.push({x:s,y:n+(i-n)*r/(e-1)});e=8;for(let r=1;r<=e;r++)a.push({x:o+(s-o)*r/e,y:n}),a.push({x:o+(s-o)*r/e,y:i})}a=a.map((r=>h(e,r,t)));const p=a.map((e=>e.x)),c=a.map((e=>e.y));return new l({xmin:Math.min.apply(null,p),xmax:Math.max.apply(null,p),ymin:Math.min.apply(null,c),ymax:Math.max.apply(null,c),spatialReference:f})}let d=class extends p{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,r){const{coeffX:t,coeffY:o}=r;if(null==t||!t.length||null==o||!o.length||t.length!==o.length)return null;const n=[];for(let e=0;e<t.length;e++)n.push(t[e]),n.push(o[e]);return n}writeForwardCoefficients(e,r,t){const o=[],n=[];for(let r=0;r<(null==e?void 0:e.length);r++)r%2==0?o.push(e[r]):n.push(e[r]);r.coeffX=o,r.coeffY=n}get inverseCoefficients(){let e=this._get("inverseCoefficients");const r=this._get("forwardCoefficients");return!e&&r&&this.polynomialOrder<2&&(e=function(e){const[r,t,o,n,s,i]=e,f=o*i-s*n,l=s*n-o*i;return[(s*t-r*i)/f,(o*t-r*n)/l,i/f,n/l,-s/f,-o/l]}(r)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,r){const{inverseCoeffX:t,inverseCoeffY:o}=r;if(null==t||!t.length||null==o||!o.length||t.length!==o.length)return null;const n=[];for(let e=0;e<t.length;e++)n.push(t[e]),n.push(o[e]);return n}writeInverseCoefficients(e,r,t){const o=[],n=[];for(let r=0;r<(null==e?void 0:e.length);r++)r%2==0?o.push(e[r]):n.push(e[r]);r.inverseCoeffX=o,r.inverseCoeffY=n}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const r=h(this.forwardCoefficients,e,this.polynomialOrder);return new f({x:r.x,y:r.y,spatialReference:e.spatialReference})}return x(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const r=h(this.inverseCoefficients,e,this.polynomialOrder);return new f({x:r.x,y:r.y,spatialReference:e.spatialReference})}return x(this.inverseCoefficients,e,this.polynomialOrder)}};e([r({json:{write:!0}})],d.prototype,"polynomialOrder",void 0),e([r()],d.prototype,"forwardCoefficients",void 0),e([s("forwardCoefficients",["coeffX","coeffY"])],d.prototype,"readForwardCoefficients",null),e([i("forwardCoefficients")],d.prototype,"writeForwardCoefficients",null),e([r({json:{write:!0}})],d.prototype,"inverseCoefficients",null),e([s("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],d.prototype,"readInverseCoefficients",null),e([i("inverseCoefficients")],d.prototype,"writeInverseCoefficients",null),e([r()],d.prototype,"affectsPixelSize",null),e([t({PolynomialXform:"polynomial"})],d.prototype,"type",void 0),d=e([o("esri.layers.support.rasterTransforms.PolynomialTransform")],d);const v=d,C={GCSShiftXform:u,IdentityXform:y,PolynomialXform:v},w=Object.keys(C);function g(e){const r=null==e?void 0:e.type;return!e||w.includes(r)}function j(e){if(!(null==e?void 0:e.type))return null;const r=C[null==e?void 0:e.type];if(r){const t=new r;return t.read(e),t}return null}export{u as G,v as P,g as i,j as r};
