/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import e from"../request.js";import{p as t,a as s}from"./utils3.js";import"../geometry.js";import{e as r,d as n}from"./project.js";import o from"../geometry/Polygon.js";import{fromJSON as a,getJsonType as i}from"../geometry/support/jsonUtils.js";import{c as f,g as c,l as p,o as y,r as m,t as g}from"./trimExtend.js";import u from"../rest/support/GeneralizeParameters.js";import l from"../rest/support/LengthsParameters.js";import d from"../rest/support/OffsetParameters.js";import S from"../rest/support/RelationParameters.js";import{urlToObject as O}from"../core/urlUtils.js";import h from"../rest/support/TrimExtendParameters.js";import J from"../geometry/Polyline.js";async function N(r,n,o){const a=t(r),i={...a.query,f:"json",...n.toJSON()},f=s(i,o);return e(a.path+"/areasAndLengths",f).then((e=>e.data))}async function j(n,a,i,f){const c=a[0].spatialReference,p=t(n),y={...p.query,f:"json",sr:JSON.stringify(c.toJSON()),polygons:JSON.stringify(r(a).geometries),polylines:JSON.stringify(r(i).geometries)},m=s(y,f);return e(p.path+"/autoComplete",m).then((({data:e})=>(e.geometries||[]).map((({rings:e})=>new o({spatialReference:c,rings:e})))))}async function R(r,n,a){const i=t(r),f={...i.query,f:"json",...n.toJSON()},c=n.outSpatialReference||n.geometries[0].spatialReference,p=s(f,a);return e(i.path+"/buffer",p).then((e=>(e.data.geometries||[]).map((({rings:e})=>new o({spatialReference:c,rings:e})))))}async function q(n,o,i){const f=o[0].spatialReference,c=t(n),p={...c.query,f:"json",sr:JSON.stringify(f.toJSON()),geometries:JSON.stringify(r(o))},y=s(p,i);return e(c.path+"/convexHull",y).then((({data:e})=>a(e.geometry).set({spatialReference:f})))}async function w(s,r,n,o){const f=t(s),c=r[0].spatialReference,p={...o,query:{...f.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:i(r[0]),geometries:r}),cutter:JSON.stringify(n)}},y=await e(f.path+"/cut",p),{cutIndexes:m,geometries:g=[]}=y.data;return{cutIndexes:m,geometries:g.map((e=>{const t=a(e);return t.spatialReference=c,t}))}}async function v(r,n,o){const i=n.geometries[0].spatialReference,f=t(r),c={...f.query,f:"json",...n.toJSON()},p=s(c,o);return e(f.path+"/densify",p).then((({data:e})=>(e.geometries||[]).map((e=>a(e).set({spatialReference:i})))))}async function P(s,n,o,f){const c=n[0].spatialReference,p=t(s);let y={query:{...p.query,f:"json",sr:JSON.stringify(c.toJSON()),geometries:JSON.stringify(r(n)),geometry:JSON.stringify({geometryType:i(o),geometry:o.toJSON()})}};return f&&(y={...f,...y}),e(p.path+"/difference",y).then((({data:e})=>(e.geometries||[]).map((e=>a(e).set({spatialReference:c})))))}async function T(r,n,o){const a=t(r),i={...a.query,f:"json",...n.toJSON()},f=s(i,o);return e(a.path+"/distance",f).then((({data:e})=>e&&e.distance))}async function k(r,n,o){const a={};null!=n.sr&&"object"==typeof n.sr?a.sr=n.sr.wkid||JSON.stringify(n.sr):a.sr=n.sr,a.strings=JSON.stringify(n.strings);const i=n.conversionType||"mgrs";a.conversionType=f.toJSON(i),a.conversionMode=n.conversionMode;const c=t(r),p={...c.query,f:"json",...a},y=s(p,o);return e(c.path+"/fromGeoCoordinateString",y).then((({data:e})=>e.coordinates))}async function x(r,n,o){const i=(n=u.from(n)).toJSON(),f=c(n),p=t(r),y={...p.query,f:"json",...f},m=i.geometries[0].spatialReference,g=s(y,o);return e(p.path+"/generalize",g).then((({data:e})=>(e.geometries||[]).map((e=>a(e).set({spatialReference:m})))))}async function b(n,o,f,c){const p=o[0].spatialReference,y=t(n),m={...y.query,f:"json",sr:JSON.stringify(p.toJSON()),geometries:JSON.stringify(r(o)),geometry:JSON.stringify({geometryType:i(f),geometry:f.toJSON()})},g=s(m,c);return e(y.path+"/intersect",g).then((({data:e})=>(e.geometries||[]).map((e=>a(e).set({spatialReference:p})))))}function M(r,n,o){const i=n.map((e=>e.toJSON())),f=n[0].spatialReference,c=t(r),p={...c.query,f:"json",sr:f.wkid?f.wkid:JSON.stringify(f.toJSON()),polygons:JSON.stringify(i)},y=s(p,o);return e(c.path+"/labelPoints",y).then((({data:e})=>(e.labelPoints||[]).map((e=>a(e).set({spatialReference:f})))))}async function C(r,n,o){n=l.from(n);const a=p(n),i=t(r),f={...i.query,f:"json",...a},c=s(f,o);return e(i.path+"/lengths",c).then((({data:e})=>e))}async function E(r,n,o){n=d.from(n);const i=y(n),f=t(r),c={...f.query,f:"json",...i},p=n.geometries[0].spatialReference,m=s(c,o);return e(f.path+"/offset",m).then((({data:e})=>(e.geometries||[]).map((e=>a(e).set({spatialReference:p})))))}async function G(r,n,o){n=S.from(n);const a=m(n),i=t(r),f={...i.query,f:"json",...a},c=s(f,o);return e(i.path+"/relation",c).then((({data:e})=>e.relations))}async function z(r,n,o,f){const c=n.spatialReference,p=t(r),y={...p.query,f:"json",sr:JSON.stringify(c.toJSON()),target:JSON.stringify({geometryType:i(n),geometry:n.toJSON()}),reshaper:JSON.stringify(o.toJSON())},m=s(y,f);return e(p.path+"/reshape",m).then((({data:e})=>a(e.geometry).set({spatialReference:c})))}async function D(t,s,o){const a="string"==typeof t?O(t):t,f=s[0].spatialReference,c=i(s[0]),p={...o,query:{...a.query,f:"json",sr:f.wkid?f.wkid:JSON.stringify(f),geometries:JSON.stringify(r(s))}},{data:y}=await e(a.path+"/simplify",p);return n(y.geometries,c,f)}async function I(r,n,o){const a={};null!=n.sr&&"object"==typeof n.sr?a.sr=n.sr.wkid||JSON.stringify(n.sr):a.sr=n.sr,a.coordinates=JSON.stringify(n.coordinates);const i=n.conversionType||"mgrs";a.conversionType=f.toJSON(i),a.conversionMode=n.conversionMode,a.numOfDigits=n.numOfDigits,a.rounding=n.rounding,a.addSpaces=n.addSpaces;const c=t(r),p={...c.query,f:"json",...a},y=s(p,o);return e(c.path+"/toGeoCoordinateString",y).then((({data:e})=>e.strings))}async function L(r,n,o){n=h.from(n);const a=g(n),i=t(r),f={...i.query,f:"json",...a},c=n.sr,p=s(f,o);return e(i.path+"/trimExtend",p).then((({data:e})=>(e.geometries||[]).map((({paths:e})=>new J({spatialReference:c,paths:e})))))}async function U(n,o,i){const f=o[0].spatialReference,c=t(n),p={...c.query,f:"json",sr:JSON.stringify(f.toJSON()),geometries:JSON.stringify(r(o))},y=s(p,i);return e(c.path+"/union",y).then((({data:e})=>a(e.geometry).set({spatialReference:f})))}export{N as a,j as b,R as c,q as d,w as e,v as f,P as g,T as h,k as i,x as j,b as k,M as l,C as m,z as n,E as o,L as p,G as r,D as s,I as t,U as u};
