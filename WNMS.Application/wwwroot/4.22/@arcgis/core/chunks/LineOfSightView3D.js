/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../core/Accessor.js";import{E as s}from"./Evented.js";import{W as i,HandleOwnerMixin as o}from"../core/HandleOwner.js";import{i as r,b as n,o as a,z as l,r as p,G as m,k as c,C as u}from"../core/lang.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{subclass as y}from"../core/accessorSupport/decorators/subclass.js";import{A as h}from"./AnalysisView3D.js";import"../geometry.js";import g from"../core/Handles.js";import{h as j,m as v}from"./handleUtils.js";import{createTask as b,ignoreAbortErrors as f}from"../core/promiseUtils.js";import{r as _,i as C,s as A,b as L}from"./reactiveUtils.js";import{b as O,m as S,s as V,n as w,f as T,g as E,ab as I,F as P,q as D,ae as R,U}from"./mathUtils.js";import{projectBoundingRect as z}from"../geometry/projection.js";import{x,g as F}from"./aaBoundingRect.js";import{e as G,c as H}from"./ray.js";import{L as M}from"./LineOfSightRayIntersector.js";import{g as B}from"./ElevationProvider.js";import{t as N}from"./intersectorUtilsConversions.js";import{I as k,T as W}from"./Scheduler.js";import q from"../geometry/Point.js";import Q from"../core/Collection.js";import J from"../Color.js";import{c as Z}from"./mat4f64.js";import{L as K}from"./LineVisualElement.js";import"./deprecate.js";import"./Logger.js";import"../config.js";import"./object.js";import"./string.js";import"./metadata.js";import"./ArrayPool.js";import"../core/scheduling.js";import"./nextTick.js";import"../core/Error.js";import"../core/watchUtils.js";import"./shared.js";import"./Promise.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./JSONSupport.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./writer.js";import"../geometry/support/webMercatorUtils.js";import"./Ellipsoid.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"./jsonMap.js";import"../geometry/support/jsonUtils.js";import"./common.js";import"./unitUtils.js";import"./projectionEllipsoid.js";import"./mat4.js";import"./pe.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./geodesicConstants.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./vectorStacks.js";import"./quatf64.js";import"./vec2f64.js";import"./vec4f64.js";import"./screenUtils.js";import"./dehydratedFeatures.js";import"./byteSizeEstimations.js";import"./aaBoundingBox.js";import"./quantizationUtils.js";import"../layers/support/Field.js";import"./enumeration.js";import"./domains.js";import"../layers/support/CodedValueDomain.js";import"../layers/support/Domain.js";import"../layers/support/InheritedDomain.js";import"../layers/support/RangeDomain.js";import"./fieldType.js";import"./ray2.js";import"./vec2.js";import"./tileUtils.js";import"./Intersector.js";import"./boundedPlane.js";import"./lineSegment.js";import"./plane.js";import"./sphere.js";import"./utils14.js";import"./mat3.js";import"./quat.js";import"./vec3f32.js";import"./Util2.js";import"./doublePrecisionUtils.js";import"./debugFlags.js";import"./colorUtils.js";import"./vec4f32.js";import"./VisualElement.js";import"./ScreenSpacePass.js";import"../Graphic.js";import"../PopupTemplate.js";import"../layers/support/fieldUtils.js";import"./arcadeOnDemand.js";import"../popup/content.js";import"../popup/content/AttachmentsContent.js";import"../popup/content/Content.js";import"../popup/content/CustomContent.js";import"../popup/content/ExpressionContent.js";import"../popup/ElementExpressionInfo.js";import"../popup/content/FieldsContent.js";import"../popup/FieldInfo.js";import"../popup/support/FieldInfoFormat.js";import"./date.js";import"./number.js";import"./locale.js";import"../popup/content/MediaContent.js";import"../popup/content/BarChartMediaInfo.js";import"./chartMediaInfoUtils.js";import"./MediaInfo.js";import"../popup/content/support/ChartMediaInfoValue.js";import"../popup/content/support/ChartMediaInfoValueSeries.js";import"../popup/content/ColumnChartMediaInfo.js";import"../popup/content/ImageMediaInfo.js";import"../popup/content/support/ImageMediaInfoValue.js";import"../popup/content/LineChartMediaInfo.js";import"../popup/content/PieChartMediaInfo.js";import"../popup/content/TextContent.js";import"../popup/ExpressionInfo.js";import"../popup/LayerOptions.js";import"../popup/RelatedRecordsInfo.js";import"../popup/support/RelatedRecordsInfoFieldOrder.js";import"../support/actions/ActionBase.js";import"./Identifiable.js";import"../support/actions/ActionButton.js";import"../support/actions/ActionToggle.js";import"../symbols.js";import"../symbols/CIMSymbol.js";import"../symbols/Symbol.js";import"../symbols/ExtrudeSymbol3DLayer.js";import"../symbols/Symbol3DLayer.js";import"./utils.js";import"../symbols/edges/Edges3D.js";import"./materialUtils.js";import"./opacityUtils.js";import"../symbols/edges/SketchEdges3D.js";import"../symbols/edges/SolidEdges3D.js";import"./Symbol3DMaterial.js";import"../symbols/FillSymbol.js";import"../symbols/SimpleLineSymbol.js";import"../symbols/LineSymbol.js";import"../symbols/LineSymbolMarker.js";import"../symbols/FillSymbol3DLayer.js";import"../symbols/patterns/LineStylePattern3D.js";import"../symbols/patterns/StylePattern3D.js";import"./utils2.js";import"./colors.js";import"./symbolLayerUtils3D.js";import"../symbols/Font.js";import"../symbols/IconSymbol3DLayer.js";import"./persistableUrlUtils.js";import"../symbols/LabelSymbol3D.js";import"../symbols/Symbol3D.js";import"./collectionUtils.js";import"../portal/Portal.js";import"./Loadable.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"../portal/PortalGroup.js";import"../symbols/LineSymbol3DLayer.js";import"../symbols/ObjectSymbol3DLayer.js";import"../symbols/PathSymbol3DLayer.js";import"../symbols/TextSymbol3DLayer.js";import"../symbols/WaterSymbol3DLayer.js";import"./Thumbnail.js";import"./Symbol3DVerticalOffset.js";import"../symbols/callouts/Callout3D.js";import"../symbols/callouts/LineCallout3D.js";import"../symbols/LineSymbol3D.js";import"../symbols/MarkerSymbol.js";import"../symbols/MeshSymbol3D.js";import"../symbols/PictureFillSymbol.js";import"./urlUtils.js";import"../symbols/PictureMarkerSymbol.js";import"../symbols/PointSymbol3D.js";import"../symbols/PolygonSymbol3D.js";import"../symbols/SimpleFillSymbol.js";import"../symbols/SimpleMarkerSymbol.js";import"../symbols/TextSymbol.js";import"../symbols/WebStyleSymbol.js";import"./mathUtils2.js";import"./StencilUtils.js";import"./Texture.js";import"./Program.js";import"./parser.js";import"./_commonjsHelpers.js";import"./geometryDataUtils.js";import"./triangle.js";import"./BufferView.js";import"./frustum.js";import"./InterleavedLayout.js";import"./types.js";import"./lineUtils.js";import"./triangulationUtils.js";import"./earcut.js";import"./deduplicate.js";import"./compilerUtils.js";import"./vec2f32.js";import"./FramebufferObject.js";import"./Camera.js";import"./PhysicallyBasedRendering.glsl.js";import"./OrderIndependentTransparency.js";import"./glUtil.js";import"./MemCache.js";import"./floatRGBA.js";let X=class extends e{constructor(t){super(t),this.elevationAlignedTargetLocation=null,this.inputPoints={isValid:!1,observer:O(),observerSurfaceNormal:null,target:O(),targetSurfaceNormal:null,observerAdjusted:O(),targetAdjusted:O()},this.computationResult={start:O(),end:O(),intersection:O(),isValid:!1,isTargetVisible:!1},this.result=null}updateComputationResults(){this.notifyChange("computationResult")}updateInputPoints(){this.notifyChange("inputPoints")}onElevationChange(){this.notifyChange("elevationAlignedTargetLocation")}};t([d()],X.prototype,"target",void 0),t([d()],X.prototype,"elevationAlignedTargetLocation",void 0),t([d()],X.prototype,"inputPoints",void 0),t([d()],X.prototype,"computationResult",void 0),t([d()],X.prototype,"result",void 0),X=t([y("esri.views.3d.analysis.LineOfSight.LineOfSightAnalysis")],X);let Y=class extends e{constructor(t){super(t),this.target=null,this.intersectedGraphic=null,this.intersectedLocation=null,this.elevationAlignedTargetLocation=null}};t([d()],Y.prototype,"target",void 0),t([d()],Y.prototype,"intersectedGraphic",void 0),t([d()],Y.prototype,"intersectedLocation",void 0),t([d()],Y.prototype,"elevationAlignedTargetLocation",void 0),t([d()],Y.prototype,"visible",void 0),Y=t([y("esri.views.3d.analysis.LineOfSight.LineOfSightResult")],Y);let $=class extends(s.EventedMixin(e)){constructor(t){super(t),this._updatingHandles=new i,this._frameTask=k,this._handles=new g,this._analysisHandles=new g}initialize(){var t;const e=null==(t=this.view.resourceController)?void 0:t.scheduler;e&&(this._frameTask=e.registerTask(W.LINE_OF_SIGHT_TOOL)),this._handles.add([this._connectObserver(),this._connectAnalyses(),this._connectTargets()]),this._intersector=new M({view:this.view})}destroy(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(t){this._frameTask.priority=t}get _analyses(){return this.analysisViewData.analyses}get _observerEngineLocation(){return this.analysisViewData.observerEngineLocation}set _observerEngineLocation(t){this.analysisViewData.observerEngineLocation=t}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(t){const{inputPoints:e}=t;return{inputPoints:e}}computeAnalysis(t){const e=t.analysis,{inputPoints:s,computationResult:i}=e,{observerAdjusted:o,targetAdjusted:r}=s,{start:n,end:a}=i;S(n,o),S(a,r);this._canComputeAnalysis(e)?this._computeAnalysisIntersection(t):this._interpolateAnalysisIntersection(t),e.updateComputationResults(),this.emit("result-changed",{target:t.analysis.target,result:e.result})}_adjustStartEndPositions(t){const e=this._screenPixelSize,s=this.view,{inputPoints:i}=t,{observer:o,observerSurfaceNormal:n,target:a,targetSurfaceNormal:l,observerAdjusted:p,targetAdjusted:m}=i,c=it;r(n)?S(c,n):V(c,a,o);const u=e;w(c,c),T(c,c,Math.min(u,1)),E(p,o,c),r(l)?S(c,l):V(c,o,a);const d=s.state.camera.computeScreenPixelSizeAt(a);w(c,c),T(c,c,Math.min(d,1)),E(m,a,c)}_computeAnalysisIntersection({analysis:t,interpolationInfo:e}){const{view:s}=this,{sceneIntersectionHelper:i,renderCoordsHelper:o}=s;if(n(i))return;const a=this._intersector.intersector,{computationResult:l,inputPoints:p}=t,{observer:m,target:c}=p,{start:u,end:d}=l,y=G(u,d,ot);i.intersectToolIntersectorRay(y,a);const h=l.intersection,g=it,j=a.results.min.getIntersectionPoint(h);let v=!0;if(j){S(e.originalIntersection,h),S(e.originalObserver,u),S(e.originalTarget,d),o.fromRenderCoords(h,g,s.spatialReference);const t=1-I(d,c)/I(u,c);v=I(m,h)>=t*I(m,c)}const b=new q(g,s.spatialReference);{const{result:e,target:i}=t;r(e)?(e.target=i,e.intersectedGraphic=v?null:N(a.results.min,s),e.intersectedLocation=v?null:b,e.visible=!!j&&v):t.result=new Y({target:i,elevationAlignedTargetLocation:t.elevationAlignedTargetLocation,intersectedGraphic:v?null:N(a.results.min,s),intersectedLocation:v?null:b,visible:!!j&&v})}l.isValid=p.isValid=!0,l.isTargetVisible=v}_interpolateAnalysisIntersection({analysis:t,interpolationInfo:e}){const{computationResult:s,inputPoints:i}=t,{start:o,end:r,intersection:n}=s,{originalIntersection:a,originalObserver:l,originalTarget:p}=e;if(S(n,a),i.isValid){const t=it,e=I(l,a)/I(l,p);P(t,o,l),T(t,t,1-e),E(n,n,t),P(t,r,p),T(t,t,e),E(n,n,t),s.isValid=!0}else t.result=null,s.isValid=!1,s.isTargetVisible=!1}_canComputeAnalysis(t){const e=this.analysisViewData.elevationAlignedObserver,s=this.view.frustum;if(n(e)||n(t.target)||n(s))return!1;const{observerAdjusted:i,targetAdjusted:o}=t.inputPoints,r=s.intersectsPoint(i),a=s.intersectsPoint(o);return r&&a}_onObserverChange(t,e){if(n(t))return this.analysis.targets.removeAll(),void(this.analysisViewData.elevationAlignedObserver=null);this.analysisViewData.elevationAlignedObserver=this._applyElevationAlignment(t,e);const s=O();this.view.renderCoordsHelper.toRenderCoords(this.analysisViewData.elevationAlignedObserver,s),this._observerEngineLocation=s,this.priority=W.LINE_OF_SIGHT_TOOL_INTERACTIVE}_applyElevationAlignment(t,e){if(t.hasZ&&(n(e)||0===e.type))return t;const s=t.clone();return s.z=a(B(this.view.elevationProvider,s),0),s}_onObserverChangeForAnalysis(t){t.inputPoints.isValid=!1}_onObserverEngineForAnalysis(t,e,s){const{inputPoints:i}=t;if(S(i.observer,e),r(s)){const t=this._intersector.updateFromIntersectionResult(s);r(t)&&this.view.renderCoordsHelper.toRenderCoords(t,i.observer),i.observerSurfaceNormal=D(s.normal)}else i.observerSurfaceNormal=null;this._adjustStartEndPositions(t),t.updateInputPoints(),this.priority=W.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetLocationChange(t,e,s){const i=t.inputPoints;if(i.isValid=!1,r(e)){if(t.elevationAlignedTargetLocation=this._applyElevationAlignment(e,s),this.view.renderCoordsHelper.toRenderCoords(t.elevationAlignedTargetLocation,i.target),r(s)){const t=this._intersector.updateFromIntersectionResult(s);r(t)&&this.view.renderCoordsHelper.toRenderCoords(t,i.target),i.targetSurfaceNormal=D(s.normal)}else i.targetSurfaceNormal=null;this._adjustStartEndPositions(t),t.updateInputPoints()}this.priority=W.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectAnalysisToTarget(t){return j([_((()=>t.target.location),(e=>{et(e,t.target.intersection)||(t.target.intersection=null)}),C),_((()=>({analysis:t,targetLocation:t.target.location,targetIntersection:t.target.intersection})),(({analysis:t,targetLocation:e,targetIntersection:s})=>{r(e)&&this._onTargetLocationChange(t,e,s)}),A)])}_connectAnalysisToObserver(t){return _((()=>({analysis:t,observer:this.analysisViewData.elevationAlignedObserver})),(({analysis:t})=>{this._onObserverChangeForAnalysis(t)}),A)}_connectAnalysisToObserverEngine(t){return _((()=>({analysis:t,observer:this._observerEngineLocation,observerIntersection:this.analysis.intersection})),(({analysis:t,observer:e,observerIntersection:s})=>{this._onObserverEngineForAnalysis(t,e,s)}),A)}_connectAnalysisToCamera(t){return _((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:e})=>{t.inputPoints.isValid&&!e||t.updateInputPoints()}),L)}_connectAnalysisToElevation(t){return this.view.elevationProvider.on("elevation-change",(e=>{if(!this._canComputeAnalysis(t))return;const s=this.analysis.observer;tt(e.extent,e.spatialReference,s)&&this._onObserverChange(s,this.analysis.intersection);const i=t.target;r(i)&&tt(e.extent,e.spatialReference,i.location)&&t.onElevationChange()}))}_connectAnalysisForCompute(t){let e=m;const s={analysis:t,interpolationInfo:{originalIntersection:O(),originalObserver:O(),originalTarget:O()}};return j([_((()=>this.getLineOfSightComputationDependencies(t)),(()=>{e=l(e),e=b((async t=>{await f(this._frameTask.schedule((()=>this.computeAnalysis(s)),t))}))}),A),v((()=>e=l(e)))])}_connectAnalysis(t){const e=this._analysisHandles;e.has(t)||e.add([this._connectAnalysisToTarget(t),this._connectAnalysisToObserver(t),this._connectAnalysisToObserverEngine(t),this._connectAnalysisToCamera(t),this._connectAnalysisToElevation(t),this._connectAnalysisForCompute(t)],t)}_disconnectAnalysis(t){this._analysisHandles.remove(t)}_onAnalysesCollectionChange(t){t.added.forEach((t=>this._connectAnalysis(t))),t.removed.forEach((t=>this._disconnectAnalysis(t)))}_onTargetsChange(){return this._analyses.removeAll(),this.analysis.targets.forEach((t=>this._addTarget(t))),this._updatingHandles.addOnCollectionPropertyChange(this.analysis,"targets",(t=>this._onTargetCollectionChange(t)))}_onTargetCollectionChange(t){t.added.forEach((t=>this._addTarget(t))),t.removed.forEach((t=>this._removeTarget(t)))}_onCursorTargetChange(t,e){r(e)&&this._removeTarget(e),r(t)&&this._addTarget(t)}_addTarget(t){this._analyses.some((e=>e.target===t))||this._analyses.add(new X({target:t}))}_removeTarget(t){const e=this._analyses.find((e=>e.target===t));this._analyses.remove(e)}_connectObserver(){return j([_((()=>this.analysis.observer),(t=>{et(t,this.analysis.intersection)||(this.analysis.intersection=null)}),C),_((()=>({observer:this.analysis.observer,intersection:this.analysis.intersection})),(({observer:t,intersection:e})=>this._onObserverChange(t,e)),A)])}_connectAnalyses(){let t=null;return j([_((()=>this._analyses),(()=>{p(t),t=this._updatingHandles.addOnCollectionPropertyChange(this,"_analyses",(t=>this._onAnalysesCollectionChange(t))),this._analyses.forEach((t=>this._connectAnalysis(t)))}),A),v((()=>t=p(t)))])}_connectTargets(){let t=null;return j([_((()=>this.analysis.targets),(()=>{t=p(t),t=this._onTargetsChange()}),A),_((()=>this.analysisViewData.cursorTarget),((t,e)=>{this._onCursorTargetChange(t,e)})),v((()=>{t=p(t)}))])}get _isCameraDirty(){const t=this.analysisViewData.elevationAlignedObserver,{view:e}=this,{renderCoordsHelper:s}=e;if(n(t)||n(s))return!1;const i=it;s.toRenderCoords(t,i);const o=e.state.camera.computeScreenPixelSizeAt(i);return Math.abs((o-this._screenPixelSize)/this._screenPixelSize)>st}};function tt(t,e,s){return!n(s)&&(z(t,e,rt,s.spatialReference),x(rt,s))}function et(t,e){return n(e)||r(t)&&t.equals(e.point)}t([d({constructOnly:!0})],$.prototype,"analysis",void 0),t([d({constructOnly:!0})],$.prototype,"analysisViewData",void 0),t([d({constructOnly:!0})],$.prototype,"view",void 0),t([d()],$.prototype,"updating",null),t([d()],$.prototype,"priority",null),t([d()],$.prototype,"_analyses",null),t([d()],$.prototype,"_observerEngineLocation",null),t([d()],$.prototype,"_screenPixelSize",null),t([d({readOnly:!0})],$.prototype,"_updatingHandles",void 0),t([d()],$.prototype,"_frameTask",void 0),t([d()],$.prototype,"_isCameraDirty",null),$=t([y("esri.views.3d.analysis.LineOfSight.LineOfSightController")],$);const st=.1,it=O(),ot=H(),rt=F();let nt=class extends e{constructor(t){super(t),this.innerWidth=2,this.outerWidth=8,this.visibleInnerColor=new J([3,252,111,1]),this.visibleOuterColor=new J([3,252,111,.15]),this.occludedInnerColor=new J([252,3,69,1]),this.occludedOuterColor=new J([252,3,69,.1]),this.undefinedInnerColor=new J([255,255,255,1]),this.undefinedOuterColor=new J([127,127,127,.2])}};t([d({type:Number})],nt.prototype,"innerWidth",void 0),t([d({type:Number})],nt.prototype,"outerWidth",void 0),t([d({type:J})],nt.prototype,"visibleInnerColor",void 0),t([d({type:J})],nt.prototype,"visibleOuterColor",void 0),t([d({type:J})],nt.prototype,"occludedInnerColor",void 0),t([d({type:J})],nt.prototype,"occludedOuterColor",void 0),t([d({type:J})],nt.prototype,"undefinedInnerColor",void 0),t([d({type:J})],nt.prototype,"undefinedOuterColor",void 0),nt=t([y("esri.views.3d.analysis.LineOfSight.LineOfSightConfiguration")],nt);let at=class extends e{constructor(){super(...arguments),this.analyses=new Q,this.elevationAlignedObserver=null,this.configuration=new nt,this.observerEngineLocation=O(),this.cursorTarget=null}};t([d()],at.prototype,"analyses",void 0),t([d()],at.prototype,"elevationAlignedObserver",void 0),t([d({type:nt})],at.prototype,"configuration",void 0),t([d()],at.prototype,"observerEngineLocation",void 0),t([d()],at.prototype,"cursorTarget",void 0),at=t([y("esri.views.3d.analysis.LineOfSight.LineOfSightViewData")],at);let lt=class extends e{constructor(t){super(t),this._handle=null,this._analysisHandles=new g}initialize(){this._handle=this._connectAnalyses()}destroy(){this._handle=p(this._handle),this._analysisHandles=c(this._analysisHandles)}get visible(){return this.analysisView.visible&&!this.analysisView.suspended}get _analyses(){return this.analysisView.analysisViewData.analyses}get _configuration(){return this.analysisView.analysisViewData.configuration}get _opacity(){return this.analysisView.fullOpacity}createLineOfSightVisualization(){const t=this._configuration,e=this._opacity,s={view:this.view,attached:!0,width:t.outerWidth,innerWidth:t.innerWidth},i=J.toUnitRGBA(t.visibleOuterColor);R(i,i,e);const o=J.toUnitRGBA(t.visibleInnerColor);R(o,o,e);const r=J.toUnitRGBA(t.occludedOuterColor);R(r,r,e);const n=J.toUnitRGBA(t.occludedInnerColor);R(n,n,e);const a=J.toUnitRGBA(t.undefinedOuterColor);R(a,a,e);const l=J.toUnitRGBA(t.undefinedInnerColor);R(l,l,e);return{visibleLineVisualElement:new K({...s,color:i,innerColor:o}),occludedLineVisualElement:new K({...s,color:r,innerColor:n}),undefinedLineVisualElement:new K({...s,color:a,innerColor:l})}}destroyLineOfSightVisualization(t){t.visibleLineVisualElement=c(t.visibleLineVisualElement),t.occludedLineVisualElement=c(t.occludedLineVisualElement),t.undefinedLineVisualElement=c(t.undefinedLineVisualElement)}updateLineOfSightVisualization(t,e){const s=this.visible,i=this._configuration,{computationResult:o,inputPoints:r}=t,{start:n,end:a,intersection:l,isValid:p,isTargetVisible:m}=o,{observer:c}=r,u=ut;u[12]=c[0],u[13]=c[1],u[14]=c[2];const d=V(pt,n,c),y=V(mt,a,c),h=V(ct,l,c),{visibleLineVisualElement:g,occludedLineVisualElement:j,undefinedLineVisualElement:v}=e;if(!s)return g.visible=!1,j.visible=!1,void(v.visible=!1);if(g.visible=!0,j.visible=!0,v.visible=!0,g.geometry=null,j.geometry=null,v.geometry=null,p)if(m){g.geometry=[[U(d),U(y)]],g.transform=u;const t=J.toUnitRGBA(i.visibleOuterColor);g.color=R(t,t,this._opacity)}else{g.geometry=[[U(d),U(h)]],g.transform=u;const t=J.toUnitRGBA(i.occludedOuterColor);g.color=R(t,t,this._opacity),j.geometry=[[U(h),U(y)]],j.transform=u}else v.geometry=[[U(d),U(y)]],v.transform=u}updateVisualizationOpacity(t,e){const s=this._configuration,i=this._opacity,o=J.toUnitRGBA(s.visibleOuterColor);R(o,o,i);const r=J.toUnitRGBA(s.visibleInnerColor);R(r,r,i);const n=J.toUnitRGBA(s.occludedOuterColor);R(n,n,i);const a=J.toUnitRGBA(s.occludedInnerColor);R(a,a,i);const l=J.toUnitRGBA(s.undefinedOuterColor);R(l,l,i);const p=J.toUnitRGBA(s.undefinedInnerColor);R(p,p,i),e.visibleLineVisualElement.color=t.computationResult.isTargetVisible?o:n,e.visibleLineVisualElement.innerColor=r,e.occludedLineVisualElement.color=n,e.occludedLineVisualElement.innerColor=a,e.undefinedLineVisualElement.color=l,e.undefinedLineVisualElement.innerColor=p}getLineOfSightVisualizationDependencies(t){const{computationResult:e}=t,{occludedOuterColor:s,visibleOuterColor:i}=this._configuration;return{computationResult:e,occludedOuterColor:s,visibleOuterColor:i,visible:this.visible}}_connectAnalysis(t){const e=this._analysisHandles;if(e.has(t))return;const s=this.createLineOfSightVisualization();e.add([_((()=>this.getLineOfSightVisualizationDependencies(t)),(()=>this.updateLineOfSightVisualization(t,s)),A),_((()=>this._opacity),(()=>this.updateVisualizationOpacity(t,s)),L),v((()=>this.destroyLineOfSightVisualization(s)))],t)}_disconnectAnalysis(t){this._analysisHandles.remove(t)}_connectAnalyses(){let t=null;return j([_((()=>this._analyses),(e=>{t=p(t),t=e.on("change",(t=>this._onAnalysesCollectionChange(t))),this._onAnalysesCollectionChange({target:e,added:e.items,removed:[],moved:[]})}),A),v((()=>t=p(t)))])}_onAnalysesCollectionChange(t){t.added.forEach((t=>this._connectAnalysis(t))),t.removed.forEach((t=>this._disconnectAnalysis(t)))}};t([d({constructOnly:!0})],lt.prototype,"analysis",void 0),t([d({constructOnly:!0})],lt.prototype,"analysisView",void 0),t([d({constructOnly:!0})],lt.prototype,"view",void 0),t([d({readOnly:!0})],lt.prototype,"visible",null),t([d()],lt.prototype,"_analyses",null),t([d()],lt.prototype,"_configuration",null),t([d()],lt.prototype,"_opacity",null),lt=t([y("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")],lt);const pt=O(),mt=O(),ct=O(),ut=Z();let dt=class extends(h(o(s.EventedMixin(e)))){constructor(t){super(t),this.type="line-of-sight-view",this.suspended=!1,this.fullOpacity=1,this.analysisViewData=new at}initialize(){const t=this.view,e=this.analysis;this._analysisController=new $({analysis:e,analysisViewData:this.analysisViewData,view:t}),this._analysisVisualization=new lt({analysis:e,analysisView:this,view:t}),this.handles.add([this._analysisController.on("result-changed",(t=>{t.target!==this.analysisViewData.cursorTarget&&this.emit("result-changed",t)}))])}destroy(){this._analysisController=c(this._analysisController),this._analysisVisualization=c(this._analysisVisualization)}get results(){return this.analysisViewData.analyses.map((t=>t.result))}get priority(){return this._analysisController.priority}set priority(t){this._analysisController.priority=t}get updating(){return r(this._analysisController)&&this._analysisController.updating}getResultForTarget(t){const e=this.analysisViewData.analyses.find((e=>e.target===t)),s=u(e,(t=>t.result));return a(s,null)}get test(){return{visualization:this._analysisVisualization,controller:this._analysisController}}};t([d()],dt.prototype,"type",void 0),t([d()],dt.prototype,"analysis",void 0),t([d({readOnly:!0})],dt.prototype,"results",null),t([d()],dt.prototype,"priority",null),t([d()],dt.prototype,"suspended",void 0),t([d()],dt.prototype,"fullOpacity",void 0),t([d()],dt.prototype,"analysisViewData",void 0),t([d()],dt.prototype,"updating",null),t([d()],dt.prototype,"_analysisController",void 0),t([d()],dt.prototype,"_analysisVisualization",void 0),dt=t([y("esri.views.3d.analysis.LineOfSight.LineOfSightView3D")],dt);const yt=dt;export{yt as default};
