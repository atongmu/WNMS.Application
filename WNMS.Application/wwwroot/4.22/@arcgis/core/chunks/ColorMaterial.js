/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{s as e,a as t,n,f as r,g as a,d as o,e as s,m as i,j as l,b as c}from"./mathUtils.js";import{f as u,b as p,c as h}from"./vec3f32.js";import{c as f,e as d,h as m}from"./plane.js";import{w as g}from"./ray.js";import{a3 as y,S as v,T as w,O as b,g as A,q as x,C as P,R as z,A as M,r as C,z as F,p as G,a as U,b as T,c as O,P as E,D,h as q,B as S,L as _,Q as j,V as I,E as H,W as $,G as V,a1 as B,a4 as W,a2 as k,a0 as L}from"./StencilUtils.js";import{g as N}from"./geometryDataUtils.js";import{d as Q}from"./Util2.js";import{D as R,l as J,o as K}from"./ScreenSpacePass.js";import{m as X,e as Y,O as Z,f as ee,g as te,c as ne,d as re,j as ae,k as oe}from"./OrderIndependentTransparency.js";import{_ as se}from"./tslib.es6.js";import{V as ie}from"./VertexColor.glsl.js";var le;!function(e){e.length=function(e,t){const n=e[t],r=e[t+1],a=e[t+2];return Math.sqrt(n*n+r*r+a*a)},e.normalize=function(e,t){const n=e[t],r=e[t+1],a=e[t+2],o=1/Math.sqrt(n*n+r*r+a*a);e[t]*=o,e[t+1]*=o,e[t+2]*=o},e.scale=function(e,t,n){e[t]*=n,e[t+1]*=n,e[t+2]*=n},e.add=function(e,t,n,r,a,o=t){(a=a||e)[o]=e[t]+n[r],a[o+1]=e[t+1]+n[r+1],a[o+2]=e[t+2]+n[r+2]},e.subtract=function(e,t,n,r,a,o=t){(a=a||e)[o]=e[t]-n[r],a[o+1]=e[t+1]-n[r+1],a[o+2]=e[t+2]-n[r+2]}}(le||(le={}));const ce=le;var ue,pe,he,fe;!function(e){const t=.5,n=[[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t],[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t]],r=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],a=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),s=new Uint16Array(36);for(let e=0;e<6;e++)for(let t=0;t<6;t++)s[6*e+t]=e;const i=new Uint16Array(36);for(let e=0;e<6;e++)i[6*e+0]=0,i[6*e+1]=1,i[6*e+2]=2,i[6*e+3]=2,i[6*e+4]=3,i[6*e+5]=0;e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(24);for(let r=0;r<8;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new y([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}],["uv0",{size:2,data:a}]],[["position",o],["normal",s],["uv0",i]])}}(ue||(ue={})),function(e){const t=.5,n=[[-t,0,-t],[t,0,-t],[t,0,t],[-t,0,t],[0,-t,0],[0,t,0]],r=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],a=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(18);for(let r=0;r<6;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new y([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}]],[["position",a],["normal",o]])}}(pe||(pe={})),function(r){const a=.5,o=u(-a,0,-a),s=u(a,0,-a),i=u(0,0,a),l=u(0,.5,0),c=p(),h=p(),f=p(),d=p(),m=p();e(c,o,l),e(h,o,s),t(f,c,h),n(f,f),e(c,s,l),e(h,s,i),t(d,c,h),n(d,d),e(c,i,l),e(h,i,o),t(m,c,h),n(m,m);const g=[o,s,i,l],v=[0,-1,0,f[0],f[1],f[2],d[0],d[1],d[2],m[0],m[1],m[2]],w=[0,1,2,3,1,0,3,2,1,3,0,2],b=[0,0,0,1,1,1,2,2,2,3,3,3];r.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(12);for(let n=0;n<4;n++)t[3*n]=g[n][0]*e[0],t[3*n+1]=g[n][1]*e[1],t[3*n+2]=g[n][2]*e[2];return new y([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:v}]],[["position",new Uint16Array(w)],["normal",new Uint16Array(b)]])}}(he||(he={})),function(v){v.createBoxGeometry=ue.createGeometry,v.createDiamondGeometry=pe.createGeometry,v.createTetrahedronGeometry=he.createGeometry,v.createSphereGeometry=function(e,t,n,r={uv:!0}){const a=-Math.PI,o=2*Math.PI,s=-Math.PI/2,i=Math.PI,l=Math.max(3,Math.floor(t)),c=Math.max(2,Math.floor(n)),u=(l+1)*(c+1),p=new Float32Array(3*u),h=new Float32Array(3*u),f=new Float32Array(2*u),d=[];let m=0;for(let t=0;t<=c;t++){const n=[],r=t/c,u=s+r*i,g=Math.cos(u);for(let t=0;t<=l;t++){const s=t/l,i=a+s*o,c=Math.cos(i)*g,d=Math.sin(u),y=-Math.sin(i)*g;p[3*m]=c*e,p[3*m+1]=d*e,p[3*m+2]=y*e,h[3*m]=c,h[3*m+1]=d,h[3*m+2]=y,f[2*m]=s,f[2*m+1]=r,n.push(m),++m}d.push(n)}const g=new Uint32Array(2*l*(c-1)*3);m=0;for(let e=0;e<c;e++)for(let t=0;t<l;t++){const n=d[e][t],r=d[e][t+1],a=d[e+1][t+1],o=d[e+1][t];0===e?(g[m++]=n,g[m++]=a,g[m++]=o):e===c-1?(g[m++]=n,g[m++]=r,g[m++]=a):(g[m++]=n,g[m++]=r,g[m++]=a,g[m++]=a,g[m++]=o,g[m++]=n)}const v=[["position",g],["normal",g]],w=[["position",{size:3,data:p,exclusive:!0}],["normal",{size:3,data:h,exclusive:!0}]];return r.uv&&(w.push(["uv0",{size:2,data:f,exclusive:!0}]),v.push(["uv0",g])),r.offset&&(v[0][0]="offset",w[0][0]="offset",v.push(["position",new Uint32Array(g.length)]),w.push(["position",{size:3,data:Float64Array.from(r.offset),exclusive:!0}])),new y(w,v)},v.createPolySphereGeometry=function(e,t,n){const r=e;let a,o;if(n)a=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const e=r*(1+Math.sqrt(5))/2;a=[-r,e,0,r,e,0,-r,-e,0,r,-e,0,0,-r,e,0,r,e,0,-r,-e,0,r,-e,e,0,-r,e,0,r,-e,0,-r,-e,0,r],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let t=0;t<a.length;t+=3)ce.scale(a,t,e/ce.length(a,t));let s={};function i(t,n){t>n&&([t,n]=[n,t]);const r=t.toString()+"."+n.toString();if(s[r])return s[r];let o=a.length;return a.length+=3,ce.add(a,3*t,a,3*n,a,o),ce.scale(a,o,e/ce.length(a,o)),o/=3,s[r]=o,o}for(let e=0;e<t;e++){const e=o.length,t=new Uint32Array(4*e);for(let n=0;n<e;n+=3){const e=o[n],r=o[n+1],a=o[n+2],s=i(e,r),l=i(r,a),c=i(a,e),u=4*n;t[u]=e,t[u+1]=s,t[u+2]=c,t[u+3]=r,t[u+4]=l,t[u+5]=s,t[u+6]=a,t[u+7]=c,t[u+8]=l,t[u+9]=s,t[u+10]=l,t[u+11]=c}o=t,s={}}const l=new Float32Array(a);for(let e=0;e<l.length;e+=3)ce.normalize(l,e);const c=[["position",o],["normal",o]],u=[["position",{size:3,data:new Float32Array(a),exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}]];return new y(u,c)},v.createPointGeometry=function(e,t,n,r,a,o,s){const i=t?[t[0],t[1],t[2]]:[0,0,0],l=e?[e[0],e[1],e[2]]:[0,0,1];o=o||[0,0];const c=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],u=null!=r&&2===r.length?r:[1,1],p=[["position",{size:3,data:i,exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}],["uv0",{size:o.length,data:o}],["color",{size:4,data:c,exclusive:!0}],["size",{size:2,data:u}]];if(null!=a){const e=new Float32Array([a[0],a[1],a[2],a[3]]);p.push(["auxpos1",{size:4,data:e}])}if(null!=s){const e=new Float32Array([s[0],s[1],s[2],s[3]]);p.push(["auxpos2",{size:4,data:e}])}return new y(p,null,1)},v.updatePointGeometry=function(e,t,n,r,a,o,s,i){if(null!=e){const{data:t}=i.getMutableAttribute("normal");t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=t){const{data:e}=i.getMutableAttribute("position");e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=n){const{data:e}=i.getMutableAttribute("color");e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3]}if(null!=r){const{data:e}=i.getMutableAttribute("size");e[0]=r[0],e[1]=r[1]}if(null!=a){const{data:e}=i.getMutableAttribute("auxpos1");e[0]=a[0],e[1]=a[1],e[2]=a[2],e[3]=a[3]}if(null!=o){const{data:e}=i.getMutableAttribute("uv0");e[0]=o[0],e[1]=o[1]}if(null!=s){const{data:e}=i.getMutableAttribute("auxpos2");e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3]}},v.createPointArrayGeometry=function(e,t){const n=new Float32Array(3*e.length),r=new Float32Array(t?3*e.length:3),a=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let s=0;s<e.length;s++)n[3*s]=e[s][0],n[3*s+1]=e[s][1],n[3*s+2]=e[s][2],t&&(r[3*s]=t[s][0],r[3*s+1]=t[s][1],r[3*s+2]=t[s][2]),a[s]=s,o[s]=0;return t||(r[0]=0,r[1]=1,r[2]=0),new y([["position",{size:3,data:n,exclusive:!0}],["normal",{size:3,data:r,exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",a],["normal",t?a:o],["uv0",o]],1)},v.createTriangleGeometry=function(){const e=new Uint16Array([0,1,2]),t=new Uint16Array([0,0,0]),n=new Uint16Array([0,0,0]);return new y([["position",{size:3,data:[0,0,0,0,0,100,100,0,0],exclusive:!0}],["normal",{size:3,data:[0,1,0],exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",e],["normal",t],["uv0",n]])};const w=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function b(e,r,a,s,i){return!(Math.abs(o(r,e))>i)&&(t(a,e,r),n(a,a),t(s,a,e),n(s,s),!0)}function A(e,t,n,r,a,o,s){return b(e,t,a,o,s)||b(e,n,a,o,s)||b(e,r,a,o,s)}v.createSquareGeometry=function(e=w){const t=new Array(12);for(let n=0;n<4;n++)for(let r=0;r<3;r++)t[3*n+r]=e[n][r];const n=new Uint32Array([0,1,2,2,3,0]),r=new Uint32Array([0,0,0,0,0,0]);return new y([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:[0,0,1],exclusive:!0}],["uv0",{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],["color",{size:4,data:[255,255,255,255],exclusive:!0}]],[["position",n],["normal",r],["uv0",n],["color",r]])},v.createConeGeometry=function(e,t,n,r,a=!0,o=!0){let s=0;const i=t,l=e;let c=u(0,s,0),p=u(0,s+l,0),h=u(0,-1,0),f=u(0,1,0);r&&(s=l,p=u(0,0,0),c=u(0,s,0),h=u(0,1,0),f=u(0,-1,0));const d=[p,c],m=[h,f],g=n+2,v=Math.sqrt(l*l+i*i);if(r)for(let e=n-1;e>=0;e--){const t=e*(2*Math.PI/n),r=u(Math.cos(t)*i,s,Math.sin(t)*i);d.push(r);const a=u(l*Math.cos(t)/v,-i/v,l*Math.sin(t)/v);m.push(a)}else for(let e=0;e<n;e++){const t=e*(2*Math.PI/n),r=u(Math.cos(t)*i,s,Math.sin(t)*i);d.push(r);const a=u(l*Math.cos(t)/v,i/v,l*Math.sin(t)/v);m.push(a)}const w=new Uint32Array(2*(n+2)*3),b=new Uint32Array(2*(n+2)*3);let A=0,x=0;if(a){for(let e=3;e<d.length;e++)w[A++]=1,w[A++]=e-1,w[A++]=e,b[x++]=0,b[x++]=0,b[x++]=0;w[A++]=d.length-1,w[A++]=2,w[A++]=1,b[x++]=0,b[x++]=0,b[x++]=0}if(o){for(let e=3;e<d.length;e++)w[A++]=e,w[A++]=e-1,w[A++]=0,b[x++]=e,b[x++]=e-1,b[x++]=1;w[A++]=0,w[A++]=2,w[A++]=d.length-1,b[x++]=1,b[x++]=2,b[x++]=m.length-1}const P=new Float32Array(3*g);for(let e=0;e<g;e++)P[3*e]=d[e][0],P[3*e+1]=d[e][1],P[3*e+2]=d[e][2];const z=new Float32Array(3*g);for(let e=0;e<g;e++)z[3*e]=m[e][0],z[3*e+1]=m[e][1],z[3*e+2]=m[e][2];return new y([["position",{size:3,data:P,exclusive:!0}],["normal",{size:3,data:z,exclusive:!0}]],[["position",w],["normal",b]])},v.createCylinderGeometry=function(e,i,l,c,f,d){const m=c?h(c):u(1,0,0),g=f?h(f):u(0,0,0);d=null==d||d;const v=p();n(v,m);const w=p();r(w,v,Math.abs(e));const b=p();r(b,w,-.5),a(b,b,g);const A=u(0,1,0);Math.abs(1-o(v,A))<.2&&s(A,0,0,1);const x=p();t(x,v,A),n(x,x),t(A,x,v);const P=2*l+(d?2:0),z=l+(d?2:0),M=new Float32Array(3*P),C=new Float32Array(3*z),F=new Float32Array(2*P),G=new Uint32Array(3*l*(d?4:2)),U=new Uint32Array(3*l*(d?4:2));d&&(M[3*(P-2)+0]=b[0],M[3*(P-2)+1]=b[1],M[3*(P-2)+2]=b[2],F[2*(P-2)]=0,F[2*(P-2)+1]=0,M[3*(P-1)+0]=M[3*(P-2)+0]+w[0],M[3*(P-1)+1]=M[3*(P-2)+1]+w[1],M[3*(P-1)+2]=M[3*(P-2)+2]+w[2],F[2*(P-1)]=1,F[2*(P-1)+1]=1,C[3*(z-2)+0]=-v[0],C[3*(z-2)+1]=-v[1],C[3*(z-2)+2]=-v[2],C[3*(z-1)+0]=v[0],C[3*(z-1)+1]=v[1],C[3*(z-1)+2]=v[2]);const T=function(e,t,n){G[e]=t,U[e]=n};let O=0;const E=p(),D=p();for(let e=0;e<l;e++){const t=e*(2*Math.PI/l);r(E,A,Math.sin(t)),r(D,x,Math.cos(t)),a(E,E,D),C[3*e+0]=E[0],C[3*e+1]=E[1],C[3*e+2]=E[2],r(E,E,i),a(E,E,b),M[3*e+0]=E[0],M[3*e+1]=E[1],M[3*e+2]=E[2],F[2*e+0]=e/l,F[2*e+1]=0,M[3*(e+l)+0]=M[3*e+0]+w[0],M[3*(e+l)+1]=M[3*e+1]+w[1],M[3*(e+l)+2]=M[3*e+2]+w[2],F[2*(e+l)+0]=e/l,F[2*e+1]=1;const n=(e+1)%l;T(O++,e,e),T(O++,e+l,e),T(O++,n,n),T(O++,n,n),T(O++,e+l,e),T(O++,n+l,n)}if(d){for(let e=0;e<l;e++){const t=(e+1)%l;T(O++,P-2,z-2),T(O++,e,z-2),T(O++,t,z-2)}for(let e=0;e<l;e++){const t=(e+1)%l;T(O++,e+l,z-1),T(O++,P-1,z-1),T(O++,t+l,z-1)}}return new y([["position",{size:3,data:M,exclusive:!0}],["normal",{size:3,data:C,exclusive:!0}],["uv0",{size:2,data:F,exclusive:!0}]],[["position",G],["normal",U],["uv0",G]])},v.createTubeGeometry=function(e,t,n,r,a){n=n||10,r=null==r||r,Q(e.length>1);const o=[],s=[];for(let e=0;e<n;e++){o.push([0,-e-1,-(e+1)%n-1]);const r=e/n*2*Math.PI;s.push([Math.cos(r)*t,Math.sin(r)*t])}return v.createPathExtrusionGeometry(s,e,[[0,0,0]],o,r,a)},v.createPathExtrusionGeometry=function(o,l,h,v,w,b=u(0,0,0)){const x=o.length,P=new Float32Array(l.length*x*3+(6*h.length||0)),z=new Float32Array(l.length*x*3+(h?6:0)),M=(l.length-1)*x*6+3*v.length*2,C=new Uint32Array(M),F=new Uint32Array(M);let G=0,U=0,T=0,O=0;const E=p(),D=p(),q=p(),S=p(),_=p(),j=p(),I=p(),H=c(),$=p(),V=p(),B=p(),W=p(),k=p(),L=f();s($,0,1,0),e(D,l[1],l[0]),n(D,D),w?(a(H,l[0],b),n(q,H)):s(q,0,0,1),A(D,q,$,$,_,q,de),i(S,q),i(W,_);for(let e=0;e<h.length;e++)r(j,_,h[e][0]),r(H,q,h[e][2]),a(j,j,H),a(j,j,l[0]),P[G++]=j[0],P[G++]=j[1],P[G++]=j[2];z[U++]=-D[0],z[U++]=-D[1],z[U++]=-D[2];for(let e=0;e<v.length;e++)C[T++]=v[e][0]>0?v[e][0]:-v[e][0]-1+h.length,C[T++]=v[e][1]>0?v[e][1]:-v[e][1]-1+h.length,C[T++]=v[e][2]>0?v[e][2]:-v[e][2]-1+h.length,F[O++]=0,F[O++]=0,F[O++]=0;let N=h.length;const Q=h.length-1;for(let s=0;s<l.length;s++){let c=!1;if(s>0){i(E,D),s<l.length-1?(e(D,l[s+1],l[s]),n(D,D)):c=!0,a(V,E,D),n(V,V),a(B,l[s-1],S),d(l[s],V,L);m(L,g(B,E),H)?(e(H,H,l[s]),n(q,H),t(_,V,q),n(_,_)):A(V,S,W,$,_,q,de),i(S,q),i(W,_)}w&&(a(H,l[s],b),n(k,H));for(let e=0;e<x;e++)if(r(j,_,o[e][0]),r(H,q,o[e][1]),a(j,j,H),n(I,j),z[U++]=I[0],z[U++]=I[1],z[U++]=I[2],a(j,j,l[s]),P[G++]=j[0],P[G++]=j[1],P[G++]=j[2],!c){const t=(e+1)%x;C[T++]=N+e,C[T++]=N+x+e,C[T++]=N+t,C[T++]=N+t,C[T++]=N+x+e,C[T++]=N+x+t;for(let e=0;e<6;e++)F[O++]=C[T-6+e]-Q}N+=x}const R=l[l.length-1];for(let e=0;e<h.length;e++)r(j,_,h[e][0]),r(H,q,h[e][1]),a(j,j,H),a(j,j,R),P[G++]=j[0],P[G++]=j[1],P[G++]=j[2];const J=U/3;z[U++]=D[0],z[U++]=D[1],z[U++]=D[2];const K=N-x;for(let e=0;e<v.length;e++)C[T++]=v[e][0]>=0?N+v[e][0]:-v[e][0]-1+K,C[T++]=v[e][2]>=0?N+v[e][2]:-v[e][2]-1+K,C[T++]=v[e][1]>=0?N+v[e][1]:-v[e][1]-1+K,F[O++]=J,F[O++]=J,F[O++]=J;return new y([["position",{size:3,data:P,exclusive:!0}],["normal",{size:3,data:z,exclusive:!0}]],[["position",C],["normal",F]])},v.createPolylineGeometry=function(e,t,n){Q(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),Q(3===e[0].length,"createPolylineGeometry(): malformed vertex"),Q(null==t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),Q(null==t||3===t[0].length,"createPolylineGeometry(): malformed normal");const r=new Float64Array(3*e.length),a=new Uint32Array(2*(e.length-1));let o=0,s=0;for(let t=0;t<e.length;t++){for(let n=0;n<3;n++)r[o++]=e[t][n];t>0&&(a[s++]=t-1,a[s++]=t)}const i=[],l=[];if(i.push(["position",a]),l.push(["position",{size:3,data:r,exclusive:!0}]),t){const n=new Float32Array(3*t.length);let r=0;for(let a=0;a<e.length;a++)for(let e=0;e<3;e++)n[r++]=t[a][e];i.push(["normal",a]),l.push(["normal",{size:3,data:n,exclusive:!0}])}return n&&(l.push(["color",{size:4,data:n}]),i.push(["color",N(n.length/4)])),new y(l,i,2)},v.createExtrudedTriangle=function(e,t,n,r,a=0){const o=new Array(18),s=[[-t,a,r/2],[n,a,r/2],[0,e+a,r/2],[-t,a,-r/2],[n,a,-r/2],[0,e+a,-r/2]],i=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let e=0;e<6;e++)o[3*e]=s[e][0],o[3*e+1]=s[e][1],o[3*e+2]=s[e][2];return new y([["position",{size:3,data:o,exclusive:!0}]],[["position",i]])},v.transformInPlace=function(e,t){const n=e.getMutableAttribute("position").data;for(let e=0;e<n.length;e+=3){const r=n[e],a=n[e+1],o=n[e+2];s(me,r,a,o),l(me,me,t),n[e]=me[0],n[e+1]=me[1],n[e+2]=me[2]}},v.cgToGIS=function(e,t=e){const n=e.vertexAttributes,r=n.get("position").data,a=n.get("normal").data;if(a){const e=t.getMutableAttribute("normal").data;for(let t=0;t<a.length;t+=3){const n=a[t+1];e[t+1]=-a[t+2],e[t+2]=n}}if(r){const e=t.getMutableAttribute("position").data;for(let t=0;t<r.length;t+=3){const n=r[t+1];e[t+1]=-r[t+2],e[t+2]=n}}return t},v.makeOrthoBasisDirUp=b,v.makeOrthoBasisDirUpFallback=A}(fe||(fe={}));const de=.99619469809,me=p(),ge=fe;const ye=Object.freeze({__proto__:null,build:function(e){const t=new v,n=1===e.output;return t.include(w,{linearDepth:n}),t.include(ie,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),e.multipassTerrainEnabled&&t.varyings.add("depth","float"),n&&(t.include(b,e),t.vertex.uniforms.add("cameraNearFar","vec2"),t.varyings.add("linearDepth","float")),t.vertex.code.add(A`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      ${e.multipassTerrainEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${n?A`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);`:A`transformPosition(proj, view, vpos);`}
    }
  `),t.include(x,e),t.fragment.include(P),e.multipassTerrainEnabled&&(t.fragment.include(z),t.include(M,e)),t.fragment.uniforms.add("eColor","vec4"),4===e.output&&t.include(C),t.fragment.code.add(A`
  void main() {
    discardBySlice(vpos);
    ${e.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 color = ${e.attributeColor?"vColor * eColor;":"eColor;"}

    if (color.a < ${A.float(F)}) {
      discard;
    }

    ${7===e.output?A`gl_FragColor = vec4(color.a);`:""}

    ${0===e.output?A`gl_FragColor = highlightSlice(color, vpos); ${e.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${4===e.output?A`outputHighlight();`:""};
    ${1===e.output?A`outputDepth(linearDepth);`:""};
  }
  `),t}});class ve extends O{initializeProgram(e){const t=ve.shader.get(),n=this.configuration,r=t.build({output:n.output,OITEnabled:0===n.transparencyPassType,attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,multipassTerrainEnabled:n.multipassTerrainEnabled,cullAboveGround:n.cullAboveGround});return new E(e.rctx,r,D)}bindPass(e,t){q(this.program,t.camera.projectionMatrix),this.program.setUniform4fv("eColor",e.color),4===this.configuration.output&&S(this.program,t),(1===this.configuration.output||t.multipassTerrainEnabled)&&this.program.setUniform2fv("cameraNearFar",t.camera.nearFar),t.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",t.inverseViewport),_(this.program,t))}bindDraw(e){j(this.program,e),this.program.rebindTextures(),I(this.program,this.configuration,e)}createPipeline(e,t){const n=this.configuration,r=3===e,a=2===e;return X({blending:0!==n.output&&7!==n.output||!n.transparent?null:r?Y:Z(e),culling:ee(n.cullFace),depthTest:{func:te(e)},depthWrite:r||a?n.writeDepth&&ne:null,colorWrite:re,stencilWrite:n.sceneHasOcludees?H:null,stencilTest:n.sceneHasOcludees?t?$:V:null,polygonOffset:r||a?n.polygonOffset&&we:ae(n.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this.createPipeline(this.configuration.transparencyPassType,!0),this.createPipeline(this.configuration.transparencyPassType,!1)}getPipelineState(e,t){return t?this._occludeePipelineState:super.getPipelineState(e,t)}}ve.shader=new U(ye,(()=>Promise.resolve().then((()=>ye))));const we={factor:1,units:1};class be extends T{constructor(){super(...arguments),this.output=0,this.cullFace=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.sceneHasOcludees=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}se([G({count:8})],be.prototype,"output",void 0),se([G({count:3})],be.prototype,"cullFace",void 0),se([G()],be.prototype,"slicePlaneEnabled",void 0),se([G()],be.prototype,"vertexColors",void 0),se([G()],be.prototype,"transparent",void 0),se([G()],be.prototype,"polygonOffset",void 0),se([G()],be.prototype,"enableOffset",void 0),se([G()],be.prototype,"writeDepth",void 0),se([G()],be.prototype,"sceneHasOcludees",void 0),se([G({count:4})],be.prototype,"transparencyPassType",void 0),se([G()],be.prototype,"multipassTerrainEnabled",void 0),se([G()],be.prototype,"cullAboveGround",void 0);class Ae extends B{constructor(e){super(e,Pe),this.supportsEdges=!0,this.techniqueConfig=new be}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.cullFace=this.parameters.cullFace,this.techniqueConfig.vertexColors=this.parameters.vertexColors,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.polygonOffset=this.parameters.polygonOffset,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.enableOffset=t.camera.relativeElevation<oe,this.techniqueConfig.multipassTerrainEnabled=t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.parameters}intersect(e,t,n,r,a,o,s){W(e,t,r,a,o,void 0,s)}requiresSlot(e,t){if(20===e)return!0;if(4===K(t))return 2===e;return e===(this.parameters.transparent?this.parameters.writeDepth?4:7:2)}createGLMaterial(e){return 0===e.output||7===e.output||4===e.output||1===e.output&&this.parameters.writeLinearDepth?new xe(e):null}createBufferWriter(){return new R(J)}}class xe extends k{updateParameters(e){return this.ensureTechnique(ve,e)}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:e.hasOccludees})}beginSlot(e){return 0!==this._output&&7!==this._output||this._updateOccludeeState(e),this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}const Pe={color:[1,1,1,1],transparent:!1,writeDepth:!0,writeLinearDepth:!1,vertexColors:!1,polygonOffset:!1,slicePlaneEnabled:!1,cullFace:0,sceneHasOcludees:!1,...L};export{Ae as C,ge as G};
