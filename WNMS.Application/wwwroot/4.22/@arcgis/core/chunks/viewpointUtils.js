/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import e from"../Camera.js";import"../geometry.js";import t from"../Graphic.js";import n from"../Viewpoint.js";import{r}from"./asyncUtils.js";import{i as a,o as i,b as o,u as s}from"../core/lang.js";import c from"../core/Error.js";import{createResolver as l,eachAlways as u}from"../core/promiseUtils.js";import{f,t as m}from"./mat3.js";import{c as p}from"./quatf64.js";import{c as d}from"./mat4f64.js";import{m as g,_ as h,f as y,s as v,g as x,d as w,l as R,b as M,n as b,a as T,r as j,i as z,o as G,j as S,k as C,W as A,y as H,q as k,ab as F,E as P,e as E,t as I}from"./mathUtils.js";import{projectPointToVector as B,projectVectorToVector as Z,projectVectorToPoint as q,project as U,projectBuffer as W,computeTranslationToOriginAndRotation as O}from"../geometry/projection.js";import{c as _,b as L,g as D,t as N,l as X,u as Y,a as V,z as $,h as J,A as K}from"./aaBoundingBox.js";import{d as Q,a as ee,v as te}from"./aaBoundingRect.js";import{h as ne}from"./frustum.js";import{geographicToWebMercator as re,project as ae,canProject as ie}from"../geometry/support/webMercatorUtils.js";import{g as oe}from"./projectionEllipsoid.js";import{n as se}from"./Intersector.js";import{L as ce}from"./Logger.js";import le from"../geometry/Point.js";import ue from"../geometry/SpatialReference.js";import{b as fe}from"./scaleUtils.js";import{i as me,j as pe,k as de,r as ge}from"./mat4.js";import he from"../geometry/Extent.js";import{g as ye,a as ve}from"./earthUtils.js";import{C as xe,g as we,c as Re}from"./mathUtils2.js";import{g as Me}from"./ElevationProvider.js";import{i as be}from"./spatialReferenceSupport.js";import Te from"../geometry/Geometry.js";function je(e,t,n,r){return a(e.renderCoordsHelper.fromRenderCoords(t.eye,Ae,r))&&Q(n,Ae)}function ze(e,t){return e.elevationProvider?i(e.elevationProvider.getElevation(t[0],t[1],t[2],e.renderCoordsHelper.spatialReference,"ground"),0):0}function Ge(e,t,n,r){const a=e.state.camera.clone();t&&(a.eye=t,a.center=n,a.up=r),function(e,t,n){let r=Ce[e.viewingMode];r||(r=se(e.state.viewingMode),r.options.backfacesTerrain=!e.state.isGlobal,r.options.invisibleTerrain=!0,Ce[e.viewingMode]=r);const{isGlobal:a}=e.state;if(e.sceneIntersectionHelper.intersectRay(t,r,n)&&!Se(e,t.origin,n))return!0;if(!e.renderCoordsHelper.intersectManifold(t,0,n)||Se(e,t.origin,n))return!!a&&function(e,t,n){const r=w(e.origin,e.origin),a=r-n*n,i=a>0?Math.sqrt(a)/3:1;return y(t,e.direction,i/R(e.direction)),x(t,t,e.origin),!0}(t,n,oe(e.spatialReference).radius);return!0}(e,a.ray,He)||g(He,a.center);const i=e.state.constraints,o=i.minimumPoiDistance;if(h(a.eye,He)<o){const t=i.collision.enabled;g(ke,a.viewForward),y(ke,ke,o),t?a.eye=v(Ae,He,ke):x(He,a.eye,ke);const n=e.renderCoordsHelper,r=n.getAltitude(a.eye),s=i.collision.elevationMargin;t&&r<s&&(v(ke,He,a.eye),a.eye=n.setAltitude(Ae,s,a.eye),x(He,a.eye,ke))}return a.center=He,a}function Se(e,t,n){if(!e.state.isGlobal)return!1;const r=ze(e,t),a=e.stateManager.constraintsManager.nearFarHeuristic,{far:i}=a.compute(t,n,e.renderDataExtent,r,Fe),o=i*i;return h(t,n)>o}const Ce={},Ae=M(),He=M(),ke=M(),Fe={near:0,far:0},Pe=M(),Ee=M();function Ie(){return{direction:M(),up:M()}}function Be(e,t,n,r,a){let i=b(Pe,e),o=w(i,r);const s=o>0;o=Math.abs(o),o>.99&&(o=Math.abs(w(t,r)),o<.99?(g(i,t),s&&y(i,i,-1)):i=null);let c=0;if(i){y(Ee,r,w(r,i)),v(i,i,Ee);const e=w(i,a)/(R(i)*R(a));T(Ee,i,a);c=(w(Ee,r)>0?1:-1)*j(z(e))}const l=j(z(-w(r,e)/R(e)));return n?(n.heading=c,n.tilt=l,n):{heading:c,tilt:l}}const Ze=C(0,1,0),qe=C(0,0,1),Ue=d(),We=M(),Oe=M();function _e(e,t,n,r=Ie()){me(Ue);const{direction:a,up:i}=r;return pe(Ue,Ue,-G(t)),de(Ue,Ue,G(n)),S(a,qe,Ue),y(a,a,-1),S(i,Ze,Ue),r}function Le(e,t,n,r,a){const i=e.renderSpatialReference,o=e.map&&e.spatialReference||t.spatialReference;return B(t,We,i),B(t,Oe,i),We[0]-=n/2,Oe[0]+=n/2,We[1]-=r/2,Oe[1]+=r/2,Z(We,i,We,o),Z(Oe,i,Oe,o),a?(a.xmin=We[0],a.ymin=We[1],a.xmax=Oe[0],a.ymax=Oe[1],a.spatialReference=o):a=new he(We[0],We[1],Oe[0],Oe[1],o),a}const De=Object.freeze({__proto__:null,headingTiltToDirectionUp:_e,directionToHeadingTilt:function(e,t,n,r){return Be(t,n,r,qe,Ze)},eyeForCenterWithHeadingTilt:function(e,t,n,r){const a=_e(0,n,r),i=M();return y(i,a.direction,-t),x(i,i,e),{up:a.up,eye:i,heading:n,tilt:r}},lookAtTiltToEyeTilt:function(e){return j(e)},eyeTiltToLookAtTilt:function(e){return G(e)},toExtent:Le}),Ne=C(0,0,1),Xe=b(M(),C(1,1,1)),Ye=new xe(-180,180),Ve=d(),$e=M(),Je=M();function Ke(e,t,n,r=Ie()){T($e,e,Ne),0===w($e,$e)&&T($e,e,Xe),me(Ve),ge(Ve,Ve,-G(t),e),ge(Ve,Ve,-G(n),$e);const{up:a,direction:i}=r;return T(a,$e,e),b(a,a),S(a,a,Ve),b(i,e),A(i,i),S(i,i,Ve),r}function Qe(e){const t=e[1];e[1]=-e[2],e[2]=t}function et(e,t){const n=Ke(t,e.heading,e.tilt);return e.up=n.up,e}function tt(e,t,n,r,a){let i,o,s,c;const l=t.latitude,u=t.longitude,f=ye(l,n,oe(e.spatialReference).radius)/2;i=u-f,o=u+f;const m=G(l),p=oe(e.spatialReference).radius,d=(1+Math.sin(m))/(1-Math.sin(m)),g=(d+1)*Math.tan(r/p/2),h=g*g;function y(e){const t=Math.PI/2;return(e=we.normalize(e,-t))>t&&(e=Math.PI-e),e}if(s=1.5*Math.PI-2*Math.atan(.5*(g+Math.sqrt(4*d+h))),c=s+r/p,s=y(s),c=y(c),c<s){const e=c;c=s,s=e}if(s=Math.max(j(s),-90),c=Math.min(j(c),90),o=Ye.monotonic(i,o),o-i>180){const e=(o-i-180)/2;i+=e,o-=e}const v=e.spatialReference&&e.spatialReference.isGeographic?e.spatialReference:ue.WGS84;return a?(a.xmin=i,a.ymin=s,a.xmax=o,a.ymax=c,a.spatialReference=v):a=new he(i,s,o,c,v),e.spatialReference&&e.spatialReference.isWebMercator&&re(a,!1,a),a}const nt=Object.freeze({__proto__:null,headingTiltToDirectionUp:Ke,directionToHeadingTilt:function(e,t,n,r){const a=$e,i=Je;return b(a,e),T(Je,a,Ne),0===w(Je,Je)&&T(Je,a,Xe),T(i,Je,a),Be(t,n,r,a,i)},eyeForCenterWithHeadingTilt:function(e,t,n,r){const a={eye:M(),up:null,tilt:r,heading:n},i=$e;i[0]=e[0],i[1]=e[2],i[2]=-e[1];const o=t,s=G(n),c=G(r),l=Math.sin(s),u=Math.cos(s),f=Math.sin(c),m=Math.cos(c),p=R(i);let d;if(Math.abs(c)<1e-8)d=o+p;else{const e=p/f,t=H(o/e),n=Math.PI-c-t;d=e*Math.sin(n)}const g=m*o,h=o*o*(f*f),v=u*u*h,x=d-g,w=x*x,b=v*(v+w-i[1]*i[1]);if(b<0)return y(a.eye,i,d/p),a.tilt=0,a;const T=Math.sqrt(b),j=i[1]*x,z=v+w;let S;if(S=u>0?-T+j:T+j,Math.abs(z)<1e-8)return p<1e-8?(a.eye[0]=0,a.eye[1]=0,a.eye[2]=o):y(a.eye,i,d/p),a.tilt=0,Qe(a.eye),et(a,e);a.eye[1]=S/z;const C=l*l*h,A=f*o,k=u*A*a.eye[1],F=a.eye[1]*a.eye[1],P=1-F,E=Math.sqrt(P),I=v*F+C-2*k*E*x+P*w;return Math.abs(I)<1e-8?(y(a.eye,i,d/p),a.tilt=0,Qe(a.eye),et(a,e)):(a.eye[0]=(P*(d*i[0]-g*i[0])-A*E*(i[0]*a.eye[1]*u+i[2]*l))/I,a.eye[2]=(P*(d*i[2]-g*i[2])-A*E*(i[2]*a.eye[1]*u-i[0]*l))/I,y(a.eye,a.eye,d),Qe(a.eye),et(a,e))},lookAtTiltToEyeTilt:function(e,t,n){const r=R(t),a=Math.sqrt(n*n+r*r-2*n*r*Math.cos(Math.PI-e)),i=H(n/(a/Math.sin(e)));return j(e-i)},eyeTiltToLookAtTilt:function(e,t,n){const r=G(e),a=R(t);return H(n/(a/Math.sin(r)))+r},toExtent:tt}),rt=ce.getLogger("esri.views.3d.support.cameraUtils"),at=M(),it=M(),ot={heading:0,tilt:0},st=new le,ct=new xe(-20037508.342788905,20037508.342788905),lt=new xe(-180,180);function ut(e){return e.spatialReference||ue.WGS84}function ft(e){return"global"===e.viewingMode?nt:De}function mt(e,t,n,r,a){return ft(e).headingTiltToDirectionUp(t,n,r,a)}function pt(e,t){if(o(t))return null;const n=e.renderSpatialReference,r=ft(e).headingTiltToDirectionUp,a=M();if(!B(t.position,a,n))return null;const i=r(a,t.heading,t.tilt);y(i.direction,i.direction,e.state.camera.distance),x(i.direction,i.direction,a);const s=Ge(e,a,i.direction,i.up);return s.fov=G(t.fov),s}const dt=M();function gt(t,n,r){const a=t.renderSpatialReference,i=wt(t,n.eye,n.viewForward,n.up,ot);let s=ut(t);return Z(n.eye,a,dt,s)||(s=ue.WGS84,Z(n.eye,a,dt,s)),o(r)?new e(new le(dt,s),i.heading,i.tilt,j(n.fov)):(r.position.x=dt[0],r.position.y=dt[1],r.position.z=dt[2],r.position.spatialReference=s,r.heading=i.heading,r.tilt=i.tilt,r.fov=j(n.fov),r)}function ht(e,t,n){const r=e.state.camera,a=r.width/2/r.pixelRatio;1===e.renderCoordsHelper.viewingMode&&null!=n&&(t*=Math.cos(G(n)));return a/(3779.5199999999995/(t/=e.renderCoordsHelper.unitInMeters))/Math.tan(r.fovX/2)}function yt(e,t,n){const r=e.state.camera,a=t*Math.tan(r.fovX/2);let i=3779.5199999999995/(r.width/2/r.pixelRatio/a);return 1===e.renderCoordsHelper.viewingMode&&(i/=Math.cos(G(n))),i*=e.renderCoordsHelper.unitInMeters,i}function vt(e,t,n,r,a,i){return xt(e,t,ht(e,n,t.latitude),r,a,i)}function xt(e,t,n,r,a,i){if(kt(i)){const s=new Ht(i.signal);return Rt(e,r.heading,r.tilt,t,n,a,s),void s.resolver.promise.then((t=>{const n=Gt(e,t,r.fov);if(!o(n))return i.resolver.resolve(n);i.resolver.reject()}),(e=>i.resolver.reject(e)))}const s=Rt(e,r.heading,r.tilt,t,n,a);return Gt(e,s,r.fov,i)}function wt(e,t,n,r,a){return ft(e).directionToHeadingTilt(t,n,r,a)}function Rt(e,t,n,r,i,o,s){const c=r&&r instanceof le?r:null;if(kt(s))return async function(e,t,n){const r=M();if(t)if(t instanceof le){if(B(t,r,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain){const i=await e.elevationProvider.queryElevation(t.x,t.y,t.z,t.spatialReference,"ground",n);return a(i)&&e.renderCoordsHelper.setAltitude(r,i),r}}else g(r,t);else g(r,e.state.camera.center);return r}(e,r,s.signal).then((r=>{Mt(e,t,n,c,r,i,o,s)}),(e=>s.resolver.reject(e))),null;const l=function(e,t){const n=M();if(t&&t instanceof le){if(B(t,n,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain){const r=Me(e.elevationProvider,t);a(r)&&e.renderCoordsHelper.setAltitude(n,r)}}else g(n,t||e.state.camera.center);return n}(e,r);return Mt(e,t,n,c,l,i,o,s)}function Mt(e,t,n,r,a,s,c,l){if(o(r)){const t=e.renderSpatialReference;if(r=q(a,t,ut(e)),o(r))return null}s=Math.max(s,e.state.constraints.minimumPoiDistance);const u=function(e,t,n,r,a,i){let s=0;1===i&&function(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>8)return!0;const a=e.renderSpatialReference,i=ut(e),s=q(t,a,i),c=q(e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,a,i);if(o(s)||o(c))return!1;const l=Math.tan(.5*e.state.camera.fov)*r;return c.distance(s)/l>5}(e,r,a)?(t=0,s=function(e,t,n,r){const a=e.state.constraints.tilt(t);a.max=Math.min(a.max,.5*Math.PI);const i=a.min*(1-.7)+.7*a.max,o=zt(e,r,t,n);return Math.min(o,i)}(e,a,n,r)):s=zt(e,r,a,n);return s=e.state.constraints.clampTilt(a,s),n=jt(e,r,a,s),{heading:t,tilt:n}}(e,t,n,a,s,c),f=(0,ft(e).eyeForCenterWithHeadingTilt)(a,s,u.heading,u.tilt);if(1===c&&"global"===e.viewingMode&&n>0){const o=()=>{const i=jt(e,a,s,function(e,t,n,r){const a=e.state.constraints.tilt(t);let i=zt(e,r,t,n);return i=Math.min(i,.5*Math.PI),a.min*(1-.7)+.7*i}(e,s,n,a));return Mt(e,t,i,r,a,s,c=n-i<1?0:1,l)},u=e.map.ground.navigationConstraint;if(!u||"stay-above"===u.type){if(function(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,st,e.spatialReference)&&i(Me(e.elevationProvider,st),0)>st.z-1)}(e,f.eye))return o();if(kt(l))return async function(e,t,n){if(!e.renderCoordsHelper.fromRenderCoords(t,st,e.spatialReference))return!1;const r=await e.elevationProvider.queryElevation(st.x,st.y,st.z,st.spatialReference,"ground",n);return i(r,0)>st.z-1}(e,f.eye,l.signal).then((e=>e?o():(l.resolver.resolve({eye:f.eye,up:f.up,center:k(a),heading:f.heading,tilt:f.tilt}),null))),null}}const m=!l||kt(l)?{center:M(),eye:M(),up:M(),tilt:0,heading:0}:l;return m.eye=f.eye,m.up=f.up,m.center=k(a),m.heading=f.heading,m.tilt=f.tilt,kt(l)&&l.resolver.resolve(m),m}function bt(e,t,n,r,a,s=null){const c=null!=t.zmax&&null!=t.zmin;let l,u,f;if(e.state.isGlobal){if(!be(t.spatialReference,1))return kt(s)&&s.resolver.reject(),null;const e=new le(t.xmin,t.ymin,t.spatialReference),n=new le(t.xmax,t.ymax,t.spatialReference),r=t.spatialReference.isGeographic?lt:ct;l=new le({x:r.center(e.x,n.x),y:(n.y+e.y)/2,z:c?(t.zmax+t.zmin)/2:null,spatialReference:t.spatialReference});const a=oe(t.spatialReference),i=ve(l,e,n);u=i.lon,f=i.lat,r.diff(e.x,n.x)>r.range/2&&(u+=a.halfCircumference),u=Math.min(u,a.halfCircumference),f=Math.min(f,a.halfCircumference)}else{const n=i(e.renderSpatialReference,t.spatialReference);n.equals(t.spatialReference)||(t=U(t,n)),u=t.xmax-t.xmin,f=t.ymax-t.ymin;const r=c?(t.zmax+t.zmin)/2:null;l=new le({x:t.xmin+.5*u,y:t.ymin+.5*f,z:r,spatialReference:n})}const m=c?t.zmax-t.zmin:0,p=e.state.camera,d=1/Math.tan(p.fovX/2),g=1/Math.tan(p.fovY/2),h=1/Math.tan(p.fov/2),y=Math.max(.5*u*d,.5*f*g,.5*m*h)/1;if(kt(s)){const t=new Ht(s.signal);return Rt(e,n,r,l,y,a,t),void t.resolver.promise.then((t=>{const n=Gt(e,t,e.camera.fov);if(!o(n))return s.resolver.resolve(n);s.resolver.reject()}),(e=>s.resolver.reject(e)))}const v=Rt(e,n,r,l,y,a);return Gt(e,v,e.camera.fov,s)}function Tt(e,t,n){const r=e.renderSpatialReference,a=q(n,r,ut(e));if(o(a))return null;const i=Math.tan(t.fovX/2),s=Math.tan(t.fovY/2),c=F(t.eye,n),l=2*c*i*1,u=2*c*s*1;return"global"===e.viewingMode?tt(e,a,l,u):Le(e,a,l,u)}function jt(e,t,n,r){return ft(e).lookAtTiltToEyeTilt(r,t,n)}function zt(e,t,n,r){return ft(e).eyeTiltToLookAtTilt(r,t,n)}function Gt(t,n,r,i){if(o(n))return null;const s=t.renderSpatialReference,c=q(n.eye,s,ut(t));return o(c)?null:a(i)?(i.position=c,i.heading=n.heading,i.tilt=n.tilt,i.fov=r,i):new e(c,n.heading,n.tilt,r)}function St(e,t){var n;const r=null==(n=e.basemapTerrain)?void 0:n.tilingScheme;if(r)return r.levelAtScale(t);rt.error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Ct(e,t){var n;const r=null==(n=e.basemapTerrain)?void 0:n.tilingScheme;if(r)return r.scaleAtLevel(t);rt.error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function At(t,n,r){const a=t.renderSpatialReference;let i,o;n||(n=t.state.camera);const s=ue.WGS84;return n instanceof e?(i=n.position.latitude,B(n.position,at,a),B(r,it,a),o=P(at,it)):(Z(n.center,a,it,s),i=it[1],o=n.distance),yt(t,o,i)}class Ht{constructor(e){this.signal=e,this.resolver=l()}}function kt(e){return e&&"resolver"in e}function Ft(e){return 360-Re.normalize(e)}function Pt(e){return Re.normalize(360-e)}function Et(e){return a(e)&&e.resolver&&e.resolver.reject(),null}function It(e,t,n,r=null){if(!t)return Et(r);const i=e.spatialReference||ue.WGS84;if(a(t.camera)){const e=ae(t.camera.position,i);if(o(e))return Et(r);const n=t.camera.clone();return n.position=e,function(e,t){return a(e)&&e.resolver&&e.resolver.resolve(t),t}(r,n)}if(o(t.targetGeometry))return Et(r);const s=t.get("targetGeometry.spatialReference");if(s&&!ie(s,i))return Et(r);const c=gt(e,e.state.camera);let l=1;if(null!=t.rotation&&(c.heading=Ft(t.rotation),l=0),null!=n&&(c.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const i=t.targetGeometry.clone();return a=null!=t.scale?ht(e,t.scale,n.latitude):e.state.camera.distance,xt(e,i,a,c,l,r)}return bt(e,t.targetGeometry.extent,c.heading,c.tilt,l,r)}function Bt(e,t,r=null){return o(r)&&(r=new n),Wt(e,null,t.clone(),r)}async function Zt(t,r,i){const o=function(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}(t,r);if(!o)throw new c("viewpointutils-create:no-target","Missing target for creating viewpoint");const l=new e({fov:t.camera.fov}),u=new n({camera:l});if(o.target instanceof n){const e=await async function(e,t,n,r,i){if(a(t.camera))return Lt(e,t.camera,i);i.scale=t.scale,i.rotation=t.rotation,i.targetGeometry=a(t.targetGeometry)?t.targetGeometry.clone():null,i.camera=null,null!=n.heading?i.rotation=Pt(n.heading):null!=n.rotation&&(i.rotation=n.rotation);const o=qt(e,n);null!=o&&(i.scale=o);const s=new Ht(r);return It(e,i,n.tilt,s),i.camera=await s.resolver.promise,i}(t,o.target,o,i,u);return Nt(e)}if(o.target instanceof e)return Nt(Lt(t,o.target,u));const p=null!=o.scale||null!=o.zoom;if(o.target instanceof he){const e=o.target.xmin===o.target.xmax||o.target.ymin===o.target.ymax;return Nt(p||e?await Dt(t,o,o.target.center,l,i,u):await async function(e,t,n,r,a,i){i.targetGeometry=n.clone();const o=Ge(e);gt(e,o,r);const s=Ut(r,t)?0:1,c=new Ht(a);return bt(e,n,r.heading,r.tilt,s,c),i.camera=await c.resolver.promise,i}(t,o,o.target,l,i,u))}const d={boundingBox:L(),hasZ:!1,screenSpaceObjects:[]},h=p?function(e,t){return function(e,t){return e.spatialReference?fe(t,e.spatialReference):void 0}(e,qt(e,t))}(t,o):void 0;if(await _t(t,o.target,h,d),isFinite(d.boundingBox[0])){let e;if(D(d.boundingBox,Xt),nn.x=Xt[0],nn.y=Xt[1],nn.z=Xt[2],nn.spatialReference=t.spatialReference,isFinite(nn.z)&&d.hasZ?e=X(d.boundingBox):(nn.z=void 0,e=te(N(d.boundingBox,Jt))),p||e)return Nt(await Dt(t,o,nn,l,i,u));const n=function(e,t){const n=.66;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const n=t[e].screenSpaceBoundingRect;r=Math.max(r,Math.abs(n[0]),Math.abs(n[1]),Math.abs(n[2]),Math.abs(n[3]))}const a=Math.min(e.width,e.height);return n-r/a*2}(t,d.screenSpaceObjects);return Nt(await async function(e,t,n,r,a,i,o,c){c.targetGeometry=n.clone();const l=Ge(e),u=function(e,t,n,r,a){let i=0;n.hasZ?i=n.z:e.basemapTerrain&&(i=s(Me(e.elevationProvider,n)));E(Xt,n.x,n.y,i),O(e.spatialReference,Xt,Yt,e.renderSpatialReference),f(Vt,Yt),m(Vt,Vt),L($t);const o=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let t=0;t<o.length;t++){const n=o[t];let a=r[n[2]];isFinite(a)||(a=i),E(Xt,r[n[0]],r[n[1]],a),Z(Xt,e.spatialReference,Xt,e.renderSpatialReference),Y($t,I(Xt,Xt,Vt))}const c=$($t),l=J($t),u=K($t),p=1/Math.tan(t.fovX/2),d=1/Math.tan(t.fovY/2),g=.5*Math.sqrt(c*c+u*u)*Math.max(d,p)+.5*l,h=.5*l*d+.5*Math.max(c,u);return Math.max(g,h)/a}(e,l,n,r,a);gt(e,l,i);const p=Ut(i,t)?0:1;c.scale=yt(e,u,c.targetGeometry.latitude);const d=new Ht(o);return vt(e,c.targetGeometry,c.scale,i,p,d),c.camera=await d.resolver.promise,c}(t,o,nn,d.boundingBox,n,l,i,u))}return o.position?Nt(function(e,t,n,r){const a=Ge(e);return g(Kt,a.viewForward),wt(e,a.eye,Kt,a.up,tn),n.position=new le(t.position),n.heading=null!=t.heading?t.heading:tn.heading,n.tilt=null!=t.tilt?t.tilt:tn.tilt,Wt(e,null,n,r)}(t,o,l,u)):Nt(await async function(e,t,n,r,a){const i=Ge(e),o=q(i.center,e.renderSpatialReference,e.spatialReference);return Dt(e,t,o,n,r,a)}(t,o,l,i,u))}function qt(e,t){return null==t.scale&&null!=t.zoom?Ct(e,t.zoom):t.scale}function Ut(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=Ft(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function Wt(e,t,n,r){const i=e.spatialReference||ue.WGS84;return t=a(t)?t:pt(e,n),o(t)||(r.targetGeometry=q(t.center,e.renderSpatialReference,i),r.scale=At(e,t),r.rotation=Pt(n.heading),r.camera=n),r}function Ot(e,t,n){if(!t)return;if(!ie(t.spatialReference,e.spatialReference))throw new c("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const r=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&ie(n,e.basemapTerrain.spatialReference)?Xt[2]=i(Me(e.elevationProvider,n),0):Xt[2]=0}(0,rn[t.type])(t,(e=>{r.push(e[0],e[1],e[2])}),Xt);const a=r.length/3;if(0===a)return;const o=new Array(r.length);if(W(r,t.spatialReference,0,o,e.spatialReference,0,a)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<o.length;e+=3)t.hasZ?(Xt[0]=o[e+0],Xt[1]=o[e+1],Xt[2]=o[e+2]):(Xt[0]=o[e+0],Xt[1]=o[e+1]),Y(n.boundingBox,Xt)}}async function _t(e,n,a,i){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return nn.x=t,nn.y=r,nn.z=void 0,nn.spatialReference=e.spatialReference.isGeographic?e.spatialReference:ue.WGS84,void Ot(e,nn,i)}n&&"function"==typeof n.map?await u(n.map((t=>_t(e,t,a,i)))):n instanceof Te?Ot(e,n,i):n instanceof t&&await async function(e,t,n,a){const i=await r(e.whenViewForGraphic(t));if(!1===i.ok||o(i.value)||!("whenGraphicBounds"in i.value))return void Ot(e,t.geometry,a);const s=i.value,c=await r(s.whenGraphicBounds(t,{minDemResolution:n}));if(!1===c.ok)return void Ot(e,t.geometry,a);const{screenSpaceObjects:l,boundingBox:u}=c.value;V(a.boundingBox,u),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(u[2])&&(a.hasZ=!0)}(e,n,a,i)}function Lt(e,t,n){const r=e.spatialReference,a=ae(t.position,r);return o(a)?null:((t=t.clone()).fov=e.camera.fov,t.position=a,Wt(e,null,t,n))}async function Dt(e,t,n,r,a,i){if(o(n))throw new c("createfromcenter","invalid point");i.targetGeometry=n.clone();const s=Ge(e);if(t.position)return function(e,t,n,r,a,i){const o=e.renderSpatialReference;return B(n.position,Qt,o),B(t,en,o),i.targetGeometry=new le(t),a.position=new le(n.position),v(Kt,en,Qt),wt(e,Qt,Kt,r.up,a),i.scale=yt(e,P(Qt,en),i.targetGeometry.latitude),i.rotation=Pt(a.heading),i.camera=a,i}(e,i.targetGeometry,t,s,r,i);if(t.zoomFactor){const r=s.distance/t.zoomFactor,a=y(Xt,s.viewForward,-r);s.eye=x(Xt,s.center,a),i.scale=yt(e,r,n.latitude)}gt(e,s,r);const l=Ut(r,t)?0:1;if(!t.zoomFactor){i.scale=qt(e,t),null==i.scale&&(B(n,Xt,e.renderSpatialReference),ne(s.frustum,Xt)?i.scale=yt(e,P(s.eye,Xt),n.latitude):i.scale=At(e,s));const o=new Ht(a);vt(e,i.targetGeometry,i.scale,r,l,o),i.camera=await o.resolver.promise}return i}function Nt(e){return e&&a(e.camera)&&(e.rotation=Pt(e.camera.heading)),e}const Xt=M(),Yt=d(),Vt=p(),$t=_(),Jt=ee(),Kt=M(),Qt=M(),en=M(),tn={heading:0,tilt:0},nn=new le,rn={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const i=e.rings[a];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const i=e.paths[a];for(let e=0;e<i.length;e++)n[0]=i[e][0],n[1]=i[e][1],r&&(n[2]=i[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)},extent(e,t,n){e.hasZ?(t(E(n,e.xmin,e.ymin,e.zmin)),t(E(n,e.xmax,e.ymin,e.zmin)),t(E(n,e.xmin,e.ymax,e.zmin)),t(E(n,e.xmax,e.ymax,e.zmin)),t(E(n,e.xmin,e.ymin,e.zmax)),t(E(n,e.xmax,e.ymin,e.zmax)),t(E(n,e.xmin,e.ymax,e.zmax)),t(E(n,e.xmax,e.ymax,e.zmax))):(t(E(n,e.xmin,e.ymin,n[2])),t(E(n,e.xmax,e.ymin,n[2])),t(E(n,e.xmin,e.ymax,n[2])),t(E(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let e=0;e<r.length;e+=3)t(E(n,r[e+0],r[e+1],r[e+2]))}};export{Zt as a,pt as b,Ie as c,yt as d,je as e,Bt as f,St as g,mt as h,gt as i,Ge as j,bt as k,Rt as l,ht as m,It as n,wt as o,ze as s,Tt as t,Ct as z};
