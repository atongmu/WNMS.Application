/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{E as t}from"./Evented.js";import{HandleOwner as i}from"../core/HandleOwner.js";import{b as s,z as n,i as r,k as a,r as o,clone as p}from"../core/lang.js";import{createTask as c}from"../core/promiseUtils.js";import{c as h,b as d}from"./screenUtils.js";import{property as l}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{p as g}from"./dehydratedFeatureComparison.js";import{c as u,E as y,a as v,C as x}from"./EditGeometryOperations.js";import{E as _,c as f}from"./InteractiveToolBase.js";import{S as T}from"./SnappingContext.js";import{T as S,I as w}from"./Scheduler.js";import{m as V}from"./dehydratedFeatures.js";import{g as M,a as b}from"./elevationInfoUtils.js";class I{constructor({grabbableForEvent:e}){this.events=new t,this.interactive=!0,this.selectable=!1,this.cursor=null,this.grabbable=!0,this.grabbableForEvent=e}intersectionDistance(e,t){return 0}attach(){}detach(){}}const k=["freehand","hybrid","click"],P="click";class O{constructor(){this.next=new _}createSnapDragEventPipelineStep({predicate:e=(()=>!0),cancel:t,snappingManager:i,snappingContext:a,updatingHandles:o}){if(s(i))return e=>e;let p=null,h=null;const d=()=>{p=n(p),i.doneSnapping(),r(h)&&h.frameTask.remove(),h=null};return t.next((e=>(d(),e))),this.next=new _,t=>{if(!e(t))return t;if(p=n(p),"start"===t.action){const e="3d"===i.view.type?i.view.resourceController.scheduler.registerTask(S.SNAPPING):w;h={context:new T({editGeometryOperations:a.editGeometryOperations,elevationInfo:a.elevationInfo,pointer:a.pointer,vertexHandle:r(t.info)?t.info.handle:null,excludeFeature:a.excludeFeature,visualizer:a.visualizer}),originalPos:r(t.snapOrigin)?a.coordinateHelper.vectorToDehydratedPoint(t.snapOrigin):t.mapStart,frameTask:e}}if(r(h)){const e=h.context.coordinateHelper.vectorToDehydratedPoint(h.context.coordinateHelper.arrayToVector([h.originalPos.x,h.originalPos.y,h.originalPos.z]));e.x+=t.mapEnd.x-t.mapStart.x,e.y+=t.mapEnd.y-t.mapStart.y;const s=t.mapStart.x-h.originalPos.x,n=t.mapStart.y-h.originalPos.y,r={...t,action:"udpate"},a=h.context,d=i.update(e,h.context);if(t.mapEnd.x=d.x+s,t.mapEnd.y=d.y+n,"end"!==t.action){const t=h.frameTask;p=c((async o=>{const p=await t.schedule((()=>i.snap(e,a,o)),o);if(p.valid){const e=await t.schedule((()=>p.apply()),o);g(e,d)||(r.mapEnd.x=e.x+s,r.mapEnd.y=e.y+n,this.next.execute(r))}})),o.addPromise(p.promise)}}return"end"===t.action&&d(),t}}}let D=class extends(t.EventedMixin(i)){constructor(e){super(e),this._createOperationCompleted=!1,this._pointerDownStates=new Set,this._snappingPipeline=new O,this._snappingTask=null,this._stagedVertex=null,this.snapToSceneEnabled=null,s(e.elevationInfo)&&(this.elevationInfo={mode:e.hasZ?"absolute-height":"on-the-ground",offset:0})}initialize(){var e,t;this.coordinateHelper=u(this.hasZ,this.hasM,this.view.spatialReference);const i="3d"===this.view.type?null==(e=this.view)||null==(t=e.resourceController)?void 0:t.scheduler:null;this._frameTask=i?i.registerTask(S.SNAPPING):w;const s="viewingMode"in this.view.state?this.view.state.viewingMode:2,n="segment"===this.geometryType||"multipoint"===this.geometryType?"polyline":this.geometryType;this._editGeometryOperations=new y(new v(n,this.coordinateHelper,s)),this._activeComponent=new x(this.spatialReference,s),this._editGeometryOperations.data.components.push(this._activeComponent),this.handles.add(this._editGeometryOperations.on(["vertex-add","vertex-update","vertex-remove"],(e=>{const t=e.vertices.map((e=>({componentIndex:0,vertexIndex:e.index,coordinates:this.coordinateHelper.vectorToArray(e.pos)}))),i=t.map((e=>e.coordinates));switch(e.type){case"vertex-add":this.emit(e.type,{...e,added:i,vertices:t});break;case"vertex-update":this.emit(e.type,{...e,updated:i,vertices:t});break;case"vertex-remove":this.emit(e.type,{...e,removed:i,vertices:t})}}))),this._manipulator=new I({grabbableForEvent:e=>"click"!==this.drawingMode||"touch"===e.pointerType&&this._snappingEnabled&&1===this._pointerDownStates.size}),this.manipulators.add(this._manipulator),this._manipulator.grabbable="point"!==this.geometryType,this.handles.add([this._createManipulatorDragPipeline(this._manipulator),this._manipulator.events.on("immediate-click",(e=>this._onImmediateClick(e))),this._manipulator.events.on("immediate-double-click",(e=>this._onImmediateDoubleClick(e)))])}destroy(){this._editGeometryOperations=a(this._editGeometryOperations),this._frameTask=o(this._frameTask)}get _snappingEnabled(){return r(this.snappingManager)&&this.snappingManager.options.effectiveEnabled}get canRedo(){return this._editGeometryOperations.canRedo}get canUndo(){return this._editGeometryOperations.canUndo}get committedVertices(){return this._activeComponent.vertices.map((e=>this.coordinateHelper.vectorToArray(e.pos)))}set drawingMode(e){this._set("drawingMode",null!=e?e:"click")}get hasStagedVertex(){return r(this._stagedVertex)}get interactive(){return this._manipulator.interactive}set interactive(e){this._manipulator.interactive=e}get isCompleted(){return this._createOperationCompleted}get numCommittedVertices(){return this._activeComponent.vertices.length}get numVertices(){return r(this._stagedVertex)?this._activeComponent.vertices.length+1:this._activeComponent.vertices.length}get spatialReference(){return this.view.spatialReference}get stagedVertex(){return this._stagedVertex}set stagedVertex(e){if(s(e))this.discardStagedVertex();else if(!r(this._stagedVertex)||!g(this._stagedVertex,e)){if(s(this._stagedVertex))this._stagedVertex=p(e);else{if(g(this._stagedVertex,e))return;this._stagedVertex.x=e.x,this._stagedVertex.y=e.y,this._stagedVertex.z=e.z,this._stagedVertex.m=e.m,this._stagedVertex.hasZ=e.hasZ,this._stagedVertex.hasM=e.hasM,this._stagedVertex.spatialReference=e.spatialReference}this.emit("cursor-update",{updated:null,vertices:[{componentIndex:0,vertexIndex:this._activeComponent.vertices.length,coordinates:this.coordinateHelper.pointToArray(e)}],operation:"apply",type:"vertex-update"})}}get updating(){return this.updatingHandles.updating}get vertices(){const e=this.committedVertices;return r(this._stagedVertex)&&e.push(this.coordinateHelper.pointToArray(this._stagedVertex)),e}cancel(){this.complete({aborted:!0})}commitStagedVertex(){if(this._snappingTask=n(this._snappingTask),r(this._stagedVertex)){const e=this._stagedVertex;this._stagedVertex=null,this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(e))}}complete(e){const t=e&&e.aborted||!1;n(this._snappingTask),r(this.snappingManager)&&this.snappingManager.doneSnapping(),"segment"===this.geometryType||"point"===this.geometryType?this.commitStagedVertex():this.discardStagedVertex();const i="multipoint"===this.geometryType&&0===this.numVertices||"polyline"===this.geometryType&&this.numVertices<2||"polygon"===this.geometryType&&this.numVertices<3;this._createOperationCompleted=!i,(this.isCompleted||t)&&this.emit("complete",{vertices:this.vertices.map(((e,t)=>({componentIndex:0,vertexIndex:t,coordinates:e}))),aborted:t,type:"complete"})}discardStagedVertex(){this._stagedVertex=null}onInputEvent(e){switch(e.type){case"pointer-down":this._pointerDownStates.add(e.pointerId);break;case"pointer-up":this._pointerDownStates.delete(e.pointerId)}switch(e.type){case"pointer-move":return this._onPointerMove(e);case"hold":return this._onHold(e)}}redo(){this._editGeometryOperations.redo()}undo(){r(this.snappingManager)&&this.snappingManager.doneSnapping(),this._editGeometryOperations.undo()}_closeOnClickVertexIndex(e){const t=this._activeComponent;if("polygon"===this.geometryType&&t.vertices.length>2){if(this._vertexWithinPointerDistance(t.vertices[0].pos,e))return 0;if(this._vertexWithinPointerDistance(t.vertices[t.vertices.length-1].pos,e))return t.vertices.length-1}return null}_createManipulatorDragPipeline(e){switch(this.drawingMode){case"click":return this._createManipulatorDragPipelineClick(e);case"freehand":return this._createManipulatorDragPipelineFreehand(e);case"hybrid":return this._createManipulatorDragPipelineHybrid(e)}}_createManipulatorDragPipelineClick(e){return f(e,((e,t,i,s)=>{const n="touch"===s&&this._snappingEnabled;!this.isCompleted&&n&&(t.next(this._screenToMapDragEventStep()).next((e=>("start"===e.action&&(this.stagedVertex=e.mapStart,("segment"===this.geometryType||n&&0===this.numVertices)&&this.commitStagedVertex()),e))).next(this._snappingPipeline.createSnapDragEventPipelineStep({predicate:()=>n,cancel:i,snappingManager:this.snappingManager,snappingContext:new T({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,pointer:s,visualizer:this.snappingVisualizer}),updatingHandles:this.updatingHandles}),this._snappingPipeline.next).next((e=>(n&&(this.stagedVertex=e.mapEnd,"end"===e.action&&this.commitStagedVertex()),e))).next((e=>("end"===e.action&&("segment"!==this.geometryType&&"point"!==this.geometryType||this.complete()),e))),i.next((()=>{n&&r(this.snappingManager)&&this.snappingManager.doneSnapping()})))}))}_createManipulatorDragPipelineFreehand(e){return f(e,((e,t)=>{this.isCompleted||t.next(this._screenToMapDragEventStep()).next((e=>("start"===e.action&&(s(this.stagedVertex)&&(this.stagedVertex=e.mapStart),"segment"===this.geometryType&&this.commitStagedVertex()),e))).next((e=>{switch(e.action){case"start":case"update":this.stagedVertex=e.mapEnd,"polygon"!==this.geometryType&&"polyline"!==this.geometryType||this.commitStagedVertex();break;case"end":this.complete()}return e}))}))}_createManipulatorDragPipelineHybrid(e){return f(e,((e,t)=>{this.isCompleted||t.next(this._screenToMapDragEventStep()).next((e=>("start"===e.action&&(s(this.stagedVertex)&&(this.stagedVertex=e.mapStart),this.commitStagedVertex()),e))).next((e=>{switch(e.action){case"start":case"update":this.stagedVertex=e.mapEnd,"polygon"!==this.geometryType&&"polyline"!==this.geometryType||this.commitStagedVertex();break;case"end":"segment"!==this.geometryType&&"point"!==this.geometryType||this.complete()}return e}))}))}_getDrawSurface(){if(s(this.elevationDrawSurface))return this.drawSurface;if(!this.coordinateHelper.hasZ)return this.elevationDrawSurface.defaultZ=null,this.elevationDrawSurface;let e=this.defaultZ,t=!1;r(this.elevationInfo)&&"absolute-height"===this.elevationInfo.mode&&(t=!0),r(this.snapToSceneEnabled)&&(t=this.snapToSceneEnabled),r(this.elevationInfo)&&"on-the-ground"===this.elevationInfo.mode&&(t=!1);const i=this._activeComponent.vertices.length;return("segment"===this.geometryType||"polygon"===this.geometryType)&&i>0&&(e=this.coordinateHelper.getZ(this._activeComponent.vertices[0].pos),t=!1),t?this.drawSurface:(this.elevationDrawSurface.defaultZ=e,this.elevationDrawSurface)}_mapToScreen(e){return this._getDrawSurface().mapToScreen(e)}_onHold(e){n(this._snappingTask),"click"===this.drawingMode&&"touch"===e.pointerType&&this._snappingEnabled&&(this.stagedVertex=e.mapPoint),e.stopPropagation()}_onImmediateClick(e){if("mouse"===e.pointerType&&2===e.button||this._manipulator.dragging)return;const t=this._activeComponent,i=this._closeOnClickVertexIndex(e.screenPoint);if(r(i))return e.stopPropagation(),this.discardStagedVertex(),void this.complete();const s=this._screenToMap(e.screenPoint);if(r(s))switch(this.drawingMode){case"freehand":"point"===this.geometryType&&(this.hasStagedVertex?this.commitStagedVertex():this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(s)),this.complete());break;case"click":case"hybrid":this._snappingTask=n(this._snappingTask),this.hasStagedVertex?this.commitStagedVertex():this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(s)),("point"===this.geometryType||"segment"===this.geometryType&&2===t.vertices.length||"segment"===this.geometryType&&"hybrid"===this.drawingMode&&1===t.vertices.length)&&this.complete()}e.stopPropagation()}_onImmediateDoubleClick(e){this._manipulator.dragging||"point"===this.geometryType||(this.complete(),e.stopPropagation())}_onPointerMove(e){if(n(this._snappingTask),this._manipulator.dragging||this._pointerDownStates.has(e.pointerId)||this._manipulator.grabbing||!this._manipulator.interactive)return;const t=h(e.x,e.y),i=this._closeOnClickVertexIndex(t);if(r(i)){this.discardStagedVertex();const e={componentIndex:0,vertexIndex:i,coordinates:this.coordinateHelper.vectorToArray(this._activeComponent.vertices[i].pos)};this.emit("cursor-update",{updated:null,vertices:[e],operation:"apply",type:"vertex-update"})}else{const i=this._screenToMap(t);if(this._manipulator.cursor=r(i)?"crosshair":null,r(i))if(r(this.snappingManager)){const t=this.snappingManager,s=new T({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,pointer:e.pointerType,visualizer:this.snappingVisualizer});this.stagedVertex=t.update(i,s),this._snappingTask=c((async e=>{const n=await this._frameTask.schedule((()=>t.snap(i,s,e)),e);n.valid&&await this._frameTask.schedule((()=>{this.stagedVertex=n.apply()}),e)})),this.updatingHandles.addPromise(this._snappingTask.promise)}else this.stagedVertex=i}e.stopPropagation()}_screenToMap(e){return this._getDrawSurface().screenToMap(e)}_screenToMapDragEventStep(){let e=null;return t=>{if("start"===t.action&&(e=this._screenToMap(t.screenStart)),s(e))return null;const i=this._screenToMap(t.screenEnd);return r(i)?{...t,mapStart:e,mapEnd:i}:null}}_vertexWithinPointerDistance(e,t){const i=this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(e));return!!r(i)&&function(e,t,i){const s=e.x-t.x,n=e.y-t.y;return s*s+n*n<=i}(i,t,25)}};e([l()],D.prototype,"defaultZ",void 0),e([l({value:"click"})],D.prototype,"drawingMode",null),e([l({constructOnly:!0})],D.prototype,"elevationDrawSurface",void 0),e([l({constructOnly:!0})],D.prototype,"elevationInfo",void 0),e([l({constructOnly:!0})],D.prototype,"geometryType",void 0),e([l({constructOnly:!0})],D.prototype,"hasM",void 0),e([l({constructOnly:!0})],D.prototype,"hasZ",void 0),e([l({constructOnly:!0})],D.prototype,"manipulators",void 0),e([l({constructOnly:!0})],D.prototype,"drawSurface",void 0),e([l({constructOnly:!0})],D.prototype,"snappingManager",void 0),e([l({constructOnly:!0})],D.prototype,"snappingVisualizer",void 0),e([l()],D.prototype,"snapToSceneEnabled",void 0),e([l({readOnly:!0})],D.prototype,"updating",null),e([l({constructOnly:!0})],D.prototype,"view",void 0),D=e([m("esri.views.draw.DrawOperation")],D);class E{constructor(e,t,i,s=null){this.elevationInfo=e,this.defaultZ=t,this.view=i,this.excludeGraphics=s}screenToMap(e){if(r(this.defaultZ))return this.view.sceneIntersectionHelper.intersectElevationFromScreen(d(e.x,e.y),this.elevationInfo,this.defaultZ,this.excludeGraphics);const t=this.view.sceneIntersectionHelper.intersectElevationFromScreen(d(e.x,e.y),this.elevationInfo,0,this.excludeGraphics);return r(t)&&(t.z=void 0),t}mapToScreen(e){const t=V(e.x,e.y,M(this.view,e,this.elevationInfo),e.spatialReference);return this.view.toScreen(t)}}class C{constructor(e,t,i=[]){this.view=e,this.elevationInfo=t,this.exclude=i}screenToMap(e){const t=this.view.toMap(e,{exclude:this.exclude});return r(t)&&(t.z=b(t,this.view,this.elevationInfo)),t}mapToScreen(e){let t=e;return r(this.elevationInfo)&&(t=V(e.x,e.y,M(this.view,e,this.elevationInfo),e.spatialReference)),this.view.toScreen(t)}}class H{constructor(e){this.view=e,this.screenToMap=t=>e.toMap(t),this.mapToScreen=t=>e.toScreen(t)}}export{D,E,H as M,C as S,P as a,O as b,k as d};
