/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../geometry.js";import{rasterRendererTypes as t}from"../rasterRenderers.js";import r from"../request.js";import{L as n}from"./Logger.js";import{b as i,i as s,u as o}from"../core/lang.js";import{aliasOf as a}from"../core/accessorSupport/decorators/aliasOf.js";import"./ensureType.js";import{property as l}from"../core/accessorSupport/decorators/property.js";import{subclass as c}from"../core/accessorSupport/decorators/subclass.js";import u,{g as f}from"../geometry/SpatialReference.js";import{s as m}from"./arcgisLayerUrl.js";import{u as h}from"./commonProperties.js";import d from"../layers/support/DimensionalDefinition.js";import{R as p}from"./RasterJobHandler.js";import g from"../layers/support/TileInfo.js";import{c as x,u as y}from"./vectorFieldUtils.js";import{n as I,b,a as v,c as R}from"./rasterRendererHelper.js";import{R as w,d as T}from"./RasterSymbolizer.js";import{c as S}from"./dataUtils.js";import _ from"../geometry/Extent.js";import k from"../core/Error.js";import{a as C}from"./JSONSupport.js";import{a as H}from"./Promise.js";import{onAbort as M}from"../core/promiseUtils.js";import{R as P}from"../layers/support/RasterInfo.js";import{g as J,a as D,p as B,d as O,b as F}from"./RawBlockCache.js";import{m as E,k as z}from"./pixelUtils.js";import{l as j,p as N,s as L,a as W,g as A,b as U,c as q,d as $,e as V,f as Y}from"./rasterProjectionHelper.js";import G from"../geometry/Point.js";const X=n.getLogger("esri.layers.mixins.ImageryTileMixin"),K=n=>{let o=class extends n{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.fullExtent=null,this.interpolation="nearest",this.multidimensionalDefinition=null,this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.tileInfo=null,this.symbolizer=null}set url(e){this._set("url",m(e,X))}set renderer(e){this._set("renderer",e),this.updateRenderer()}async convertVectorFieldData(e,t){if(i(e))return null;const r=this._rasterJobHandler.instance,n=this.rasterInfo.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:n},t):x(e,n)}async createStreamlinesMesh(e,t){const r=this._rasterJobHandler.instance;return r?r.createStreamlinesMesh(e,t):S(e.rendererSettings,e.flowData,s(t.signal)?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.rasterInfo;if(i(t))return e;let r=e.multidimensionalDefinition||this.multidimensionalDefinition;!i(r)&&r.length||(r=this._getDefaultSlice());const n=e.timeExtent||this.timeExtent;if(s(r)&&s(n)&&(s(n.start)||s(n.end))){var o,a;r=r.map((e=>e.clone()));const l=null==(o=t.variables.find((({name:e})=>e===r[0].variableName)))||null==(a=o.dimensions)?void 0:a.find((({name:e})=>"StdTime"===e)),c=r.find((({dimensionName:e})=>"StdTime"===e));if(!l||!c)return{...e,multidimensionalDefinition:null};const{start:u,end:f}=n,m=i(u)?null:u.getTime(),h=i(f)?null:f.getTime(),d=null!=m?m:h,p=null!=h?h:m;if(s(l.values)){const e=l.values.filter((e=>{if(Array.isArray(e)){if(d===p)return e[0]<=d&&e[1]>=d;const t=e[0]<=d&&e[1]>d||e[0]<p&&e[1]>=p,r=e[0]>=d&&e[1]<=p||e[0]<d&&e[1]>p;return t||r}return d===p?e===d:e>=d&&e<=p}));if(e.length){const t=e.sort(((e,t)=>{var r,n,i,s;if(d===p)return(null!=(i=e[0])?i:e)-(null!=(s=t[0])?s:t);return Math.abs((null!=(r=e[1])?r:e)-p)-Math.abs((null!=(n=t[1])?n:t)-p)}))[0];c.values=[t]}else r=null}else if(l.hasRegularIntervals&&l.extent){const[e,t]=l.extent;d>t||p<e?r=null:c.values=d===p?[d]:[Math.max(e,d),Math.min(t,p)]}}return{...e,multidimensionalDefinition:r}}async updateRenderer(){if(!this.loaded)return;if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const e=this._rasterJobHandler.instance;e&&(this.symbolizer.rendererJSON=I(this.renderer.toJSON()),this.symbolizer.bind(),await e.updateSymbolizer(this.symbolizer),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(e,t){const r=e&&e.pixelBlock;if(!(s(r)&&r.pixels&&r.pixels.length>0))return null;let n;await this.updateRenderer();const i=this._rasterJobHandler.instance,{bandIds:o}=this;return n=i?await i.symbolize({...e,simpleStretchParams:t,bandIds:o}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:o}),n}getTileUrl(e,t,r){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${r}`:""}getCompatibleTileInfo(e,t,r=!1){if(!this.loaded||i(t))return null;if(r&&e.equals(this.spatialReference))return this.tileInfo;const n=f(e);return g.create({size:256,spatialReference:e,origin:n?{x:n.origin[0],y:n.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,n,o={}){if(o.requestAsImageElement){const i=this.getTileUrl(e,t,n);return r(i,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:o.signal}).then((e=>e.data))}if(s(this.rasterInfo.multidimensionalInfo)&&(o=this.normalizeRasterFetchOptions(o),i(o.multidimensionalDefinition))){const r=o.tileInfo||this.rasterInfo.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,n,r),pixelBlock:null}}return await this._initJobHandler(),"raster-shaded-relief"===this.renderer.type&&(o={...o,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,n,o)}async fetchPixels(e,t,r,n={}){return s(this.rasterInfo.multidimensionalInfo)&&(n=this.normalizeRasterFetchOptions(n),i(n.multidimensionalDefinition))?{extent:e,pixelBlock:null}:(await this._initJobHandler(),this.raster.fetchPixels(e,t,r,n))}async identify(e,t={}){return s(this.rasterInfo.multidimensionalInfo)&&(t=this.normalizeRasterFetchOptions(t),i(t.multidimensionalDefinition))?{location:e,value:null}:this.raster.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var e;const t=this.rasterInfo.multidimensionalInfo;if(!s(t)||"standard-time"!==this.rasterInfo.dataType)return!1;const r=null==(e=this.multidimensionalDefinition[0])?void 0:e.variableName;return t.variables.some((e=>e.name===r&&e.dimensions.some((e=>"StdTime"===e.name))))}getStandardTimeValue(e){return new Date(24*(e-25569)*3600*1e3).toString()}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=this._getDefaultSlice()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new p;return this._rasterJobHandler.connectionPromise=e.initialize().then((()=>{this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.renderer&&this.updateRenderer()})).catch((()=>null)),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this.raster.rasterJobHandler=null}_configDefaultInterpolation(){if(null==this.interpolation){var e;const t=b(this.rasterInfo,this.raster.tileType,null==(e=this.sourceJSON)?void 0:e.defaultResamplingMethod);this._set("interpolation",t)}}_getDefaultSlice(){const{multidimensionalInfo:e}=this.raster.rasterInfo;if(!s(e))return null;const t=e.variables[0];return t.dimensions.map((e=>{var r,n;return new d({variableName:t.name,dimensionName:e.name,values:[null!=(r=null==(n=e.values)?void 0:n[0])?r:e.extent[0]],isSlice:!0})}))}_configDefaultRenderer(){const e=this.raster.rasterInfo;var t;(this.bandIds||(this.bandIds=v(e)),this.renderer)||(this.renderer=R(e,{bandIds:this.bandIds,variableName:s(this.multidimensionalDefinition)?null==(t=this.multidimensionalDefinition[0])?void 0:t.variableName:null}));this.symbolizer?(this.symbolizer.rendererJSON=I(this.renderer.toJSON()),this.symbolizer.rasterInfo=e):this.symbolizer=new w({rendererJSON:this.renderer.toJSON(),rasterInfo:e});const r=this.symbolizer.bind();r.success||X.warn("imagery-tile-mixin",r.error||"The given renderer is not supported by the layer.")}};return e([l()],o.prototype,"_cachedRendererJson",void 0),e([l()],o.prototype,"_compatibleFullExtent",void 0),e([l()],o.prototype,"_rasterJobHandler",void 0),e([l()],o.prototype,"bandIds",void 0),e([l()],o.prototype,"copyright",void 0),e([l({type:_}),a("rasterInfo.extent")],o.prototype,"fullExtent",void 0),e([l()],o.prototype,"interpolation",void 0),e([l()],o.prototype,"ioConfig",void 0),e([l({type:[d]})],o.prototype,"multidimensionalDefinition",void 0),e([l()],o.prototype,"raster",void 0),e([l({readOnly:!0}),a("raster.rasterInfo")],o.prototype,"rasterInfo",void 0),e([l()],o.prototype,"sourceJSON",void 0),e([l({type:u}),a("rasterInfo.spatialReference")],o.prototype,"spatialReference",void 0),e([l({type:g}),a("rasterInfo.storageInfo.tileInfo")],o.prototype,"tileInfo",void 0),e([l(h)],o.prototype,"url",null),e([l({types:t})],o.prototype,"renderer",null),e([l()],o.prototype,"symbolizer",void 0),o=e([c("esri.layers.ImageryTileMixin")],o),o};let Q=class extends(H(C)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=j();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:g.create(),...e.ioConfig}}),e}set url(e){this._set("url",m(e,n.getLogger(this.declaredClass)))}async open(e){throw new k("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,n={}){const i=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(e,t,r,i);return this.fetchPixels(s,i.size[0],i.size[1],n)}async identify(e,t={}){t=this._getRequestOptionsWithSliceId(t);const{spatialReference:r,extent:n}=this.rasterInfo,{datumTransformation:o}=t;let a=N(e,r,o);if(!n.intersects(a))return{location:a,value:null};if(s(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(a);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};a=e}let l=0;if(t.srcResolution){l=L(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(l=await this.computeBestPyramidLevelForLocation(e,t),null==l)return{location:a,value:null};const c=this.identifyPixelLocation(a,l,null);if(null===c)return{location:a,value:null};const{row:u,col:f,rowOffset:m,colOffset:h}=c,d=J(this.url,t.sliceId),p=`${l}/${u}/${f}`;let g=D(d,null,p);i(g)&&(g=this.fetchRawTile(l,u,f,t),B(d,null,p,g));const x=await g;if(i(x)||!x.pixels||0===x.pixels.length)return{location:a,value:null};const I=m*this.rasterInfo.storageInfo.blockHeight+h,b=!x.mask||x.mask[I]?x.pixels.map((e=>e[I])):null,v=this.rasterInfo.dataType;if(("vector-magdir"===v||"vector-uv"===v)&&(null==b?void 0:b.length)>1){return{location:a,value:b,magdirValue:"vector-magdir"===v?[b[0],b[1]]:y([b[0],b[1]]),pyramidLevel:l}}return{location:a,value:b,pyramidLevel:l}}async fetchPixels(e,t,r,n={}){e=W(e);const o=A(e.spatialReference),a=U(e),l=A(this.rasterInfo.spatialReference),c=s(l)&&this.rasterInfo.extent.width>=l/2;if(n=this._getRequestOptionsWithSliceId(n),i(o)||0===a||1===a&&c)return this._fetchPixels(e,t,r,n);if(a>=3)return{extent:e,pixelBlock:null};const u=[],{xmin:f,xmax:m}=e,h=Math.round(o/(m-f)*t),d=h-Math.round((o/2-f)/(m-f)*t);let p=0;const g=[];for(let i=0;i<=a;i++){const s=new _({xmin:0===i?f:-o/2,xmax:i===a?m-o*i:o/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),l=0===i?h-d:i===a?t-p:h;p+=l,g.push(l);const c=this._fetchPixels(s,l,r,n);u.push(c)}const x=(await Promise.all(u)).map((e=>null==e?void 0:e.pixelBlock));let y=null;const I={width:t,height:r};y=this.rasterJobHandler?await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:x,srcMosaicSize:I,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:g},n):E(x,I,{blockWidths:g});return{extent:e,srcExtent:q(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:y}}async fetchRawPixels(e,t,r,n){const{origin:i,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:u}=t,{width:f,height:m,wrapCount:h}=r;const d=o(this._getRasterTileAlignmentInfo(e,0));n.buffer&&(c-=n.buffer.cols,u-=n.buffer.rows,f+=2*n.buffer.cols,m+=2*n.buffer.rows);const p=Math.floor(c/a),g=Math.floor(u/l),x=Math.floor((c+f-1)/a),y=Math.floor((u+m-1)/l),I=s[e];if(!I)return null;const{minRow:b,minCol:v,maxCol:R,maxRow:w}=I;if(0===h&&(y<b||x<v||g>w||p>R))return null;const T=new Array;let S=!1;const k=null==this.ioConfig.allowPartialFill?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=g;t<=y;t++)for(let r=p;r<=x;r++){const i=0===h||null==d||r<d.worldColumnCountFromOrigin?r:r%d.worldColumnCountFromOrigin-d.originColumnOffset;if(t>=b&&i>=v&&w>=t&&R>=i){const r=this._fetchRawTile(e,t,i,n);k?T.push(new Promise((e=>{r.then((t=>e(t))).catch((()=>{S=!0,e(null)}))}))):T.push(r)}else T.push(null)}if(0===T.length)return null;const C=await Promise.all(T),H={height:(y-g+1)*l,width:(x-p+1)*a},{spatialReference:M}=this.rasterInfo,P=this.getPyramidPixelSize(e),{x:J,y:D}=P;return{extent:new _({xmin:i.x+p*a*J,xmax:i.x+(x+1)*a*J,ymin:i.y-(y+1)*l*D,ymax:i.y-g*l*D,spatialReference:M}),pixelBlocks:C,mosaicSize:H,isPartiallyFilled:S}}fetchRawTile(e,t,r,n){throw new k("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return q(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?T(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,n){var i,s;const{customFetchParameters:o}=this.ioConfig,{range:a,query:l,headers:c}=t;n=null!=(i=null!=(s=n)?s:t.retryCount)?i:this.ioConfig.retryCount;const u=a?{Range:`bytes=${a.from}-${a.to}`}:null;try{return await r(e,{...t,query:{...l,...o},headers:{...c,...u}})}catch(r){if(n>0)return n--,this.request(e,t,n);throw r}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!s(t))return null;if(!s(e)||0===e.length)return null;let r=0;const n=e[0].variableName;for(let i=0;i<t.variables.length;i++){const s=t.variables[i],o=s.dimensions;if(s.name!==n){r+=o.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const a=o.map((e=>this._getDimensionValuesCount(e))),l=o.length;for(let t=0;t<l;t++){const n=e.filter((e=>e.dimensionName===o[t].name))[0];if(null==n)return null;const i=Array.isArray(n.values[0])?n.values[0][0]:n.values[0],s=this._getIndexFromDimensions(i,o[t]);if(-1===s)return null;a.shift(),r+=t===l-1?s:s*a.reduce(((e,t)=>e+t))}}return r}getTileExtentFromTileInfo(e,t,r,n){const i=n.lodAt(e);return this.getTileExtent({x:i.resolution,y:i.resolution},t,r,n.origin,n.spatialReference,n.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:r,pixelSize:n}=this.rasterInfo;if(!e.tileInfo){const i=[],s=e.maximumPyramidLevel||0;let o=Math.max(n.x,n.y),a=1/.0254*96*o;for(let e=0;e<=s;e++)i.push({level:s-e,resolution:o,scale:a}),o*=2,a*=2;const l=new G({x:r.xmin,y:r.ymax,spatialReference:t});e.tileInfo=new g({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:i}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,r=512,n){const{width:i,height:s,nativeExtent:o,pixelSize:a,spatialReference:l}=e,c=new G({x:o.xmin,y:o.ymax,spatialReference:l});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(i,s))/Math.LN2-8)));const u=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[a],n);e.storageInfo=new P({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,r,n,i,s=0,o=2){if(1===i.length&&s>0){i=[...i];let{x:e,y:t}=i[0];for(let r=0;r<s;r++)e*=o,t*=o,i.push({x:e,y:t})}const a=[],{x:l,y:c}=n;for(let n=0;n<i.length;n++){const{x:s,y:o}=i[n];a.push({minCol:Math.floor((e.xmin-l+.1*s)/t/s),maxCol:Math.floor((e.xmax-l-.1*s)/t/s),minRow:Math.floor((c-e.ymax+.1*o)/r/o),maxRow:Math.floor((c-e.ymin-.1*o)/r/o)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(0===e)return t;if(s(r)&&r.length)return r[e-1];const i=n**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,r){const{spatialReference:n,nativeExtent:i}=this.rasterInfo,{blockWidth:s,blockHeight:o,maximumPyramidLevel:a,origin:l}=this.rasterInfo.storageInfo,c=N(e,n,r);if(!i.intersects(c))return null;if(t<0||t>a)return null;const u=this.getPyramidPixelSize(t),{x:f,y:m}=u,h=(l.y-c.y)/m/o,d=(c.x-l.x)/f/s,p=Math.min(o-1,Math.floor((h-Math.floor(h))*o)),g=Math.min(s-1,Math.floor((d-Math.floor(d))*s));return{pyramidLevel:t,row:Math.floor(h),col:Math.floor(d),rowOffset:p,colOffset:g,srcLocation:c}}getTileExtent(e,t,r,n,i,s){const[o,a]=s,l=n.x+r*o*e.x,c=l+o*e.x,u=n.y-t*a*e.y,f=u-a*e.y;return new _({xmin:l,xmax:c,ymin:f,ymax:u,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,r){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<r||n.minRow>t||n.minCol>r}async _fetchPixels(e,t,r,n={}){let i=U(e);if(i>=2)return{extent:e,pixelBlock:null};const s=this._getSourceDataInfo(e,t,r,n),{pyramidLevel:a,pyramidResolution:l,srcResolution:c,srcExtent:u,srcWidth:f,srcHeight:m}=s;if(0===f||0===m)return{extent:e,srcExtent:u,pixelBlock:null};const h=o(this.rasterInfo.transform);"gcs-shift"===(null==h?void 0:h.type)&&(i=U(s.srcExtent,!0));const d=this.rasterInfo.storageInfo,p={x:Math.floor((u.xmin-d.origin.x)/l.x+.1),y:Math.floor((d.origin.y-u.ymax)/l.y+.1)},g=await this.fetchRawPixels(a,p,{width:f,height:m,wrapCount:i},n);if(!g)return{extent:e,srcExtent:u,pixelBlock:null};const x=a>0?d.pyramidBlockWidth:d.blockWidth,y=a>0?d.pyramidBlockHeight:d.blockHeight,I=x===f&&y===m&&p.x%x==0&&p.y%y==0,b=new G({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),v=!e.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:R}=n;if(!v&&I&&1===g.pixelBlocks.length&&x===t&&y===r&&c.x===b.x&&c.y===b.y)return{extent:e,srcExtent:u,pixelBlock:g.pixelBlocks[0]};const w=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:b.toJSON(),datumTransformation:R,rasterTransform:h,hasWrapAround:i>0,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy},n):$({projectedExtent:e,srcBufferExtent:g.extent,pixelSize:b,datumTransformation:R,rasterTransform:h,hasWrapAround:i>0,isAdaptive:!1});let T;const S=!n.requestRawData,_={rows:w.spacing[0],cols:w.spacing[1]},k=o(this._getRasterTileAlignmentInfo(a,g.extent.xmin)),{pixelBlocks:C,mosaicSize:H,isPartiallyFilled:M}=g;if(this.rasterJobHandler)T=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:C,srcMosaicSize:H,destDimension:S?{width:t,height:r}:null,coefs:S?w.coefficients:null,sampleSpacing:S?_:null,interpolation:n.interpolation,alignmentInfo:k,blockWidths:null},n);else{const e=E(C,H,{alignmentInfo:k});T=S?z(e,{width:t,height:r},w.coefficients,_,n.interpolation):e}return n.requestRawData?{srcExtent:u,pixelBlock:T,transformGrid:w,extent:e,isPartiallyFilled:M}:{srcExtent:u,extent:e,pixelBlock:T}}_fetchRawTile(e,t,r,n){const s=this.rasterInfo.storageInfo.blockBoundary[e];if(!s)return Promise.resolve(null);const{minRow:o,minCol:a,maxCol:l,maxRow:c}=s;if(t<o||r<a||t>c||r>l)return Promise.resolve(null);const u=J(this.url,n.sliceId),f=`${e}/${t}/${r}`;let m=D(u,n.registryId,f);if(i(m)){const i=new AbortController;m=this.fetchRawTile(e,t,r,{...n,signal:i.signal}),B(u,n.registryId,f,m,i),m.catch((()=>O(u,n.registryId,f)))}return n.signal&&M(n,(()=>{F(u,n.registryId,f)})),m}_getIndexFromDimensions(e,t){const{extent:r,interval:n,unit:i,values:s}=t;if(null!=s&&s.length)return Array.isArray(s[0])?s.findIndex((t=>t[0]<=e&&t[1]>=e)):s.indexOf(e);if(e>r[1])return-1;const o=r[0];let a=-1;if("ISO8601"===i){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":a=Math.round((e-o)/1e3/n);break;case"minutes":a=Math.round((e-o)/6e4/n);break;case"hours":a=Math.round((e-o)/36e5/n);break;case"days":a=Math.round((e-o)/864e5/n);break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(o).getUTCFullYear())/n);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(o).getUTCFullYear())/10/n)}return a}return Math.round((e-o)/n)}_getDimensionValuesCount(e){const{extent:t,interval:r,unit:n,values:i}=e;let s=(null==i?void 0:i.length)||0;if(s)return s;const o=t[0];if(0===s&&"ISO8601"===n){var a;switch((null==(a=e.intervalUnit)?void 0:a.toLowerCase())||"seconds"){case"seconds":s=Math.round((t[1]-t[0])/1e3/r);break;case"minutes":s=Math.round((t[1]-t[0])/6e4/r);break;case"hours":s=Math.round((t[1]-t[0])/36e5/r);break;case"days":s=Math.round((t[1]-t[0])/864e5/r);break;case"years":s=Math.round((new Date(t[1]).getUTCFullYear()-new Date(o).getUTCFullYear())/r);break;case"decades":s=Math.round((new Date(t[1]).getUTCFullYear()-new Date(o).getUTCFullYear())/10/r)}return s}return Math.round((t[1]-t[0])/r)}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=V(this.rasterInfo)),s(this._rasterTileAlighmentInfo.pyramidsInfo)?{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}:null}_getSourceDataInfo(e,t,r,n={}){const i={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};n.srcResolution&&(i.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,i));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:a,pyramidLevel:l}=i,c=o/t,u=a/r,f=l<s&&c*u>=16;if(f||l===s&&(c>8||u>8)||(0===o||0===a)){const o=new G({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference});let a=Y(o,this.rasterInfo.spatialReference,e,i.datumTransformation);const m=!a||n.srcResolution&&a.x+a.y<n.srcResolution.x+n.srcResolution.y;if(f&&n.srcResolution&&m){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(s-l+3>=e){const t=2**e;a={x:n.srcResolution.x*t,y:n.srcResolution.y*t}}}a&&(i.srcResolution=a,this._updateSourceDataInfo(e,i))}return(i.srcWidth/t>8||i.srcHeight/r>8)&&(i.srcWidth=0,i.srcHeight=0),i}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const r=this.rasterInfo.spatialReference,{srcResolution:n,datumTransformation:i}=t,{pyramidLevel:s,pyramidResolution:a,excessiveReading:l}=L(n,this.rasterInfo,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||q(e,r,i);if(null==c)return;const u=o(this.rasterInfo.transform);u&&(c=u.inverseTransform(c)),t.srcExtent=c;const f=Math.ceil((c.xmax-c.xmin)/a.x-.1),m=Math.ceil((c.ymax-c.ymin)/a.y-.1);t.pyramidLevel=s,t.pyramidResolution=a,t.srcWidth=f,t.srcHeight=m}_getRequestOptionsWithSliceId(e){return s(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}};e([l()],Q.prototype,"_rasterTileAlighmentInfo",void 0),e([l(h)],Q.prototype,"url",null),e([l({type:String,json:{write:!0}})],Q.prototype,"datasetName",void 0),e([l({type:String,json:{write:!0}})],Q.prototype,"datasetFormat",void 0),e([l()],Q.prototype,"rasterInfo",void 0),e([l()],Q.prototype,"ioConfig",void 0),e([l()],Q.prototype,"sourceJSON",void 0),Q=e([c("esri.layers.support.rasterDatasets.BaseRaster")],Q);const Z=Q;function ee(e,t){if(!e||!t)return[];let r=t;t.indexOf("/")>-1?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const n=[];if(t){const i=ee(e,r);for(let e=0;e<i.length;e++){ee(i[e],t).forEach((e=>n.push(e)))}return n}const i=e.getElementsByTagNameNS("*",r);if(!i||0===i.length)return[];for(let e=0;e<i.length;e++)n.push(i[e]||i.item[e]);return n}function te(e,t){if(!e||!t)return null;let r=t;t.indexOf("/")>-1?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const n=ee(e,r);return n.length>0?t?te(n[0],t):n[0]:null}function re(e,t=null){const r=t?te(e,t):e;let n;return r?(n=r.textContent||r.nodeValue,n?n.trim():null):null}function ne(e,t){const r=ee(e,t),n=[];let i;for(let e=0;e<r.length;e++)i=r[e].textContent||r[e].nodeValue,i&&(i=i.trim(),""!==i&&n.push(i));return n}function ie(e,t=null){const r=re(e,t);return null==r?void 0:r.split(" ").map((e=>Number(e)))}function se(e,t){return ne(e,t).map((e=>Number(e)))}function oe(e,t){const r=re(e,t);return Number(r)}function ae(e,t){var r;const n=null==e||null==(r=e.nodeName)?void 0:r.toLowerCase(),i=t.toLowerCase();return n.slice(n.lastIndexOf(":")+1)===i}function le(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}export{Z as B,K as I,ee as a,te as b,oe as c,se as d,ie as e,ne as f,re as g,le as h,ae as i};
