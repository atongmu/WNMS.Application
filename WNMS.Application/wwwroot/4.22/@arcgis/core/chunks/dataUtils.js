/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import"../geometry.js";import{L as t}from"./Logger.js";import{o as e}from"./mathUtils.js";import{R as n,b as r}from"../core/lang.js";import{throwIfAborted as o}from"../core/promiseUtils.js";import{g as i}from"../geometry/SpatialReference.js";import a from"../geometry/Extent.js";const l=t.getLogger("esri.views.2d.engine.flow.dataUtils");async function s(t,e,r){const i=performance.now(),a=function(t,e){const n=function(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),i=new Array(2*o+1);let a=0;for(let t=-o;t<=o;t++){const e=Math.exp(-t*t/(r*r));i[t+o]=e,a+=e}for(let t=-o;t<=o;t++)i[t+o]/=a;const l=new Float32Array(t.length);for(let r=0;r<n;r++)for(let n=0;n<e;n++){let a=0,s=0;for(let l=-o;l<=o;l++){if(n+l<0||n+l>=e)continue;const c=i[l+o];a+=c*t[2*(r*e+(n+l))+0],s+=c*t[2*(r*e+(n+l))+1]}l[2*(r*e+n)+0]=a,l[2*(r*e+n)+1]=s}const s=new Float32Array(t.length);for(let t=0;t<e;t++)for(let r=0;r<n;r++){let a=0,c=0;for(let s=-o;s<=o;s++){if(r+s<0||r+s>=n)continue;const h=i[s+o];a+=h*l[2*((r+s)*e+t)+0],c+=h*l[2*((r+s)*e+t)+1]}s[2*(r*e+t)+0]=a,s[2*(r*e+t)+1]=c}return s}(e.data,e.width,e.height,t.smoothing);if(t.interpolate){return(t,r)=>{const o=Math.floor(t),i=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(i<0||i>=e.height)return[0,0];const a=t-o,l=r-i,s=o,c=i,h=o<e.width-1?o+1:o,f=i<e.height-1?i+1:i,u=n[2*(c*e.width+s)],d=n[2*(c*e.width+h)],m=n[2*(f*e.width+s)],w=n[2*(f*e.width+h)],g=n[2*(c*e.width+s)+1],p=n[2*(c*e.width+h)+1];return[(u*(1-l)+m*l)*(1-a)+(d*(1-l)+w*l)*a,(g*(1-l)+n[2*(f*e.width+s)+1]*l)*(1-a)+(p*(1-l)+n[2*(f*e.width+h)+1]*l)*a]}}return(t,r)=>{const o=Math.round(t),i=Math.round(r);return o<0||o>=e.width||i<0||i>=e.height?[0,0]:[n[2*(i*e.width+o)+0],n[2*(i*e.width+o)+1]]}}(t,e),s=performance.now(),h=function(t,e,r,o){const i=[],a=new n,l=1/Math.max(t.lineCollisionWidth,1),s=Math.round(r*l),h=Math.round(o*l),f=new Int32Array(s*h);for(let t=0;t<f.length;t++)f[t]=-1;const u=[];for(let e=0;e<o;e+=t.lineSpacing)for(let n=0;n<r;n+=t.lineSpacing)u.push({x:n,y:e,sort:a.getFloat()});u.sort(((t,e)=>t.sort-e.sort));for(const{x:n,y:r}of u)if(a.getFloat()<t.density){const o=c(t,e,n,r,i.length,f,s,h,l);if(o.length<2)continue;i.push(o)}return i}(t,a,e.width,e.height),f=performance.now(),u=function(t,e){const r=new n,o=t.reduce(((t,e)=>t+e.length),0),i=new Float32Array(3*o),a=new Array(t.length);let l=0,s=0;for(const n of t){const t=l;for(const t of n)i[3*l+0]=t.x,i[3*l+1]=t.y,i[3*l+2]=t.t,l++;a[s++]={startVertex:t,numberOfVertices:n.length,totalTime:n[n.length-1].t,timeSeed:e?r.getFloat():0}}return{lineVertices:i,lineDescriptors:a}}(h,!0),d=performance.now(),m=function(t,e=10){const{lineVertices:n,lineDescriptors:r}=t;let o=0,i=0;for(const t of r){o+=2*t.numberOfVertices;i+=6*(t.numberOfVertices-1)}const a=new Float32Array(8*o),l=new Uint32Array(i);let s=0,c=0;function h(){l[c++]=s-2,l[c++]=s,l[c++]=s-1,l[c++]=s,l[c++]=s+1,l[c++]=s-1}function f(t,e,n,r,o,i,l){const c=8*s;let h=0;a[c+h++]=t,a[c+h++]=e,a[c+h++]=1,a[c+h++]=n,a[c+h++]=i,a[c+h++]=l,a[c+h++]=r,a[c+h++]=o,s++,a[c+h++]=t,a[c+h++]=e,a[c+h++]=-1,a[c+h++]=n,a[c+h++]=i,a[c+h++]=l,a[c+h++]=-r,a[c+h++]=-o,s++}for(const t of r){const{totalTime:r,timeSeed:o}=t;let i=null,a=null,l=null,s=null,c=null;for(let u=0;u<t.numberOfVertices;u++){const d=n[3*(t.startVertex+u)+0],m=n[3*(t.startVertex+u)+1],w=n[3*(t.startVertex+u)+2];let g=null,p=null,y=null,x=null;if(u>0){g=d-i,p=m-a;const t=Math.sqrt(g*g+p*p);if(g/=t,p/=t,u>1){let t=g+s,n=p+c;const r=Math.sqrt(t*t+n*n);t/=r,n/=r;const o=Math.min(1/(t*g+n*p),e);t*=o,n*=o,y=-n,x=t}else y=-p,x=g;null!==y&&null!==x&&(f(i,a,l,y,x,r,o),h())}i=d,a=m,l=w,s=g,c=p}f(i,a,l,-c,s,r,o)}return{vertexData:a,indexData:l}}(u),w=performance.now();if(t.profile){const t={"_createFlowFieldFromData()":Math.round(s-i),"_getStreamlines()":Math.round(f-s),"createAnimatedLinesData()":Math.round(d-f),"createLinesMesh()":Math.round(w-d),"Total elapsed time":Math.round(w-i)};l.info("createStreamlinesMesh profile",t)}return await Promise.resolve(),o(r),m}function c(t,e,n,r,o,i,a,l,s){const c=[];let h,f,u=n,d=r,m=0;c.push({x:u,y:d,t:m});for(let n=0;n<t.verticesPerLine;n++){let[n,r]=e(u,d);n*=t.velocityScale,r*=t.velocityScale;const w=Math.sqrt(n*n+r*r);if(w<t.minSpeedThreshold)return c;const g=n/w,p=r/w;u+=g*t.segmentLength,d+=p*t.segmentLength;if(m+=t.segmentLength/w,Math.acos(g*h+p*f)>t.maxTurnAngle)return c;if(t.mergeLines){const t=Math.round(u*s),e=Math.round(d*s);if(t<0||t>a-1||e<0||e>l-1)return c;const n=i[e*a+t];if(-1!==n&&n!==o)return c;i[e*a+t]=o}c.push({x:u,y:d,t:m}),h=g,f=p}return c}function h(t,n){const r=n.pixels,{width:o,height:i}=n,a=new Float32Array(o*i*2);if("vector-uv"===t)for(let t=0;t<o*i;t++)a[2*t+0]=r[0][t],a[2*t+1]=-r[1][t];else if("vector-magdir"===t)for(let t=0;t<o*i;t++){const n=r[0][t],o=e(r[1][t]),i=Math.cos(o-Math.PI/2),l=Math.sin(o-Math.PI/2);a[2*t+0]=i*n,a[2*t+1]=l*n}return{data:a,width:o,height:i}}async function f(t,e,n,r,o){const l=i(e.spatialReference);if(!l)return u(t,e,n,r,o);const[s,c]=l.valid,h=c-s,f=Math.ceil(e.width/h),d=e.width/f,m=Math.round(n/f);let w=e.xmin;const g=[];for(let n=0;n<f;n++){const n=new a({xmin:w,xmax:w+d,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});g.push(u(t,n,m,r,o)),w+=d}const p=await Promise.all(g),y={data:new Float32Array(n*r*2),width:n,height:r};let x=0;for(const t of p){for(let e=0;e<t.height;e++)for(let r=0;r<t.width;r++)x+r>=n||(y.data[2*(e*n+x+r)+0]=t.data[2*(e*t.width+r)+0],y.data[2*(e*n+x+r)+1]=t.data[2*(e*t.width+r)+1]);x+=t.width}return y}async function u(t,e,n,o,i){if("imagery"===t.type){await t.load({signal:i});const a=t.rasterInfo.dataType,l=await t.fetchImage(e,n,o,{signal:i});return!l||r(l.pixelData)||r(l.pixelData.pixelBlock)?{data:new Float32Array(n*o*2),width:n,height:o}:h(a,l.pixelData.pixelBlock)}await t.load({signal:i});const a=t.rasterInfo.dataType,l=await t.fetchPixels(e,n,o,{signal:i});return!l||r(l.pixelBlock)?{data:new Float32Array(n*o*2),width:n,height:o}:h(a,l.pixelBlock)}export{s as c,f as l};
