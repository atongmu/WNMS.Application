/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{L as e}from"./Logger.js";import{i as t,u as i,b as s}from"../core/lang.js";import{d as r}from"./screenUtils.js";import{c as o}from"./vec2.js";import{e as a,s as n,d as l,f as p,g as c,m as d,l as u,E as f,j as m,b as h}from"./mathUtils.js";import{c as g,d as v,f as x,a as P}from"./lineSegment.js";import{c as S,f as b,s as C,n as y}from"./plane.js";import{a as T,e as w}from"./BufferView.js";import{c as E}from"./geometryDataUtils.js";import{S as _,T as R,g as j,r as O,q as L,z as U,p as z,a as B,b as A,c as q,P as D,D as W,h as V,B as H,Q as M,U as N,V as F,$,E as G,W as I,G as X,a1 as Q,ai as k,a2 as J,ab as K,a0 as Y}from"./StencilUtils.js";import{e as Z}from"./Util2.js";import{l as ee,p as te,D as ie}from"./ScreenSpacePass.js";import{i as se}from"./utils14.js";import{_ as re}from"./tslib.es6.js";import{V as oe}from"./VertexColor.glsl.js";import{P as ae}from"./lineUtils.js";import{s as ne,m as le,d as pe,c as ce}from"./OrderIndependentTransparency.js";const de=Object.freeze({__proto__:null,build:function(e){const t=new _;return t.include(R,{linearDepth:!1}),t.include(oe,e),t.include(ae,{...e,stippleRequiresStretchMeasure:!1}),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),e.stippleEnabled&&(t.vertex.uniforms.add("ndcToPixel","vec2"),t.attributes.add("uv0","vec2"),t.attributes.add("auxpos1","vec3")),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(j`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),e.stippleEnabled&&(t.vertex.code.add(j`vec4 vpos2 = transformPosition(proj, view, auxpos1);
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`),e.draped||t.vertex.code.add(j`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),t.vertex.code.add(j`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`),e.draped?t.vertex.code.add(j`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`):t.vertex.code.add(j`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),t.vertex.code.add(j`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)),t.vertex.code.add(j`}`),4===e.output&&t.include(O),t.include(L,e),t.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),t.fragment.code.add(j`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${e.attributeColor?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${j.float(U)}) {
      discard;
    }

    ${0===e.output?j`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${4===e.output?j`outputHighlight();`:""}
  }
  `),t}});class ue extends q{constructor(e,t,i){super(e,t,i),this.stipplePattern=null,this.stippleTextureBind=null,this.stippleTextureRepository=e.stippleTextureRepository}get stippleEnabled(){return this.configuration.stippleEnabled&&4!==this.configuration.output}initializeProgram(e){const t=ue.shader.get(),i=this.configuration,s=t.build({output:i.output,attributeColor:i.vertexColors,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,draped:i.draped,stippleEnabled:this.stippleEnabled,stippleOffColorEnabled:i.stippleOffColorEnabled,stippleRequiresClamp:!1,stippleScaleWithLineWidth:!1,stipplePreferContinuous:i.stipplePreferContinuous});return new D(e.rctx,s,W)}dispose(){super.dispose(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,s){if(V(this.program,s.camera.projectionMatrix),this.stipplePattern!==e.stipplePattern){const t=e.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,t),this.stipplePattern=t}if(this.stippleEnabled){const{pixelSize:e,sdfNormalizer:i,pixels:r}=t(this.stippleTextureBind)?this.stippleTextureBind(this.program):{pixelSize:1,sdfNormalizer:1,pixels:1};this.program.setUniform1f("stipplePatternSDFNormalizer",i),this.program.setUniform1f("stipplePatternTextureSize",r),this.program.setUniform1f("stipplePatternPixelSize",e),this.program.setUniform1f("stipplePatternPixelSizeInv",1/e),this.program.setUniform1f("pixelRatio",s.camera.pixelRatio),this.configuration.draped?this.program.setUniform1f("worldToScreenRatio",1/s.screenToPCSRatio):this.program.setUniform1f("worldToScreenPerDistanceRatio",1/s.camera.perScreenPixelRatio),this.program.setUniform2f("ndcToPixel",s.camera.fullViewport[2]/2,s.camera.fullViewport[3]/2)}if(this.program.setUniform4fv("constantColor",e.color),this.program.setUniform1f("alphaCoverage",Math.min(1,e.width*s.camera.pixelRatio)),this.configuration.stippleOffColorEnabled){const t=i(e.stippleOffColor);this.program.setUniform4f("stippleOffColor",t[0],t[1],t[2],t.length>3?t[3]:1)}4===this.configuration.output&&H(this.program,s)}bindDraw(e){M(this.program,e),this.stippleEnabled&&!this.configuration.draped&&N(this.program,e.origin,e.camera.viewInverseTransposeMatrix),F(this.program,this.configuration,e),this.program.rebindTextures()}initializePipeline(){const e=this.configuration,t=ne(770,1,771,771),i=(t,i=null,s=null)=>le({blending:i,depthTest:$,depthWrite:s,colorWrite:pe,stencilWrite:e.sceneHasOcludees?G:null,stencilTest:e.sceneHasOcludees?t?I:X:null});return 0===e.output?(this._occludeePipelineState=i(!0,e.transparent||this.stippleEnabled?t:null,ce),i(!1,e.transparent||this.stippleEnabled?t:null,ce)):i(!1)}get primitiveType(){return 1}getPipelineState(e,t){return t?this._occludeePipelineState:super.getPipelineState(e,t)}}ue.shader=new B(de,(()=>Promise.resolve().then((()=>de))));class fe extends A{constructor(){super(...arguments),this.output=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.sceneHasOcludees=!1}}re([z({count:8})],fe.prototype,"output",void 0),re([z()],fe.prototype,"slicePlaneEnabled",void 0),re([z()],fe.prototype,"vertexColors",void 0),re([z()],fe.prototype,"transparent",void 0),re([z()],fe.prototype,"draped",void 0),re([z()],fe.prototype,"stippleEnabled",void 0),re([z()],fe.prototype,"stippleOffColorEnabled",void 0),re([z()],fe.prototype,"stipplePreferContinuous",void 0),re([z()],fe.prototype,"sceneHasOcludees",void 0);const me=e.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class he extends Q{constructor(e){super(e,xe),this._techniqueConfig=new fe}getTechniqueConfig(e,i){this._techniqueConfig.output=e,this._techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this._techniqueConfig.vertexColors=this.parameters.vertexColors,this._techniqueConfig.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._techniqueConfig.draped=20===i.slot;const s=t(this.parameters.stipplePattern);return this._techniqueConfig.stippleEnabled=s,this._techniqueConfig.stippleOffColorEnabled=s&&t(this.parameters.stippleOffColor),this._techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,this._techniqueConfig.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._techniqueConfig}getPassParameters(){return this.parameters}intersect(e,i,s,r,o,a,n,l,p){t(p)?k(e,r,p,a,1,n):this.intersectLineGeometry(e,i,s,r,n)}intersectLineGeometry(e,t,i,s,r){if(!s.options.selectionMode||se(t))return;if(!Z(i))return void me.error("intersection assumes a translation-only matrix");const m=e.vertexAttributes.get("position").data,h=s.camera,g=je;o(g,s.point);a(Oe[0],g[0]-2,g[1]+2,0),a(Oe[1],g[0]+2,g[1]+2,0),a(Oe[2],g[0]+2,g[1]-2,0),a(Oe[3],g[0]-2,g[1]-2,0);for(let e=0;e<4;e++)if(!h.unprojectFromRenderScreen(Oe[e],Le[e]))return;b(h.eye,Le[0],Le[1],Ue),b(h.eye,Le[1],Le[2],ze),b(h.eye,Le[2],Le[3],Be),b(h.eye,Le[3],Le[0],Ae);let S=Number.MAX_VALUE,T=0;for(let e=0;e<m.length-5;e+=3){if(Pe[0]=m[e]+i[12],Pe[1]=m[e+1]+i[13],Pe[2]=m[e+2]+i[14],Se[0]=m[e+3]+i[12],Se[1]=m[e+4]+i[13],Se[2]=m[e+5]+i[14],C(Ue,Pe)<0&&C(Ue,Se)<0||C(ze,Pe)<0&&C(ze,Se)<0||C(Be,Pe)<0&&C(Be,Se)<0||C(Ae,Pe)<0&&C(Ae,Se)<0)continue;if(h.projectToRenderScreen(Pe,ye),h.projectToRenderScreen(Se,Te),ye[2]<0&&Te[2]>0){n(be,Pe,Se);const e=h.frustum,t=-C(e[4],Pe)/l(be,y(e[4]));p(be,be,t),c(Pe,Pe,be),h.projectToRenderScreen(Pe,ye)}else if(ye[2]>0&&Te[2]<0){n(be,Se,Pe);const e=h.frustum,t=-C(e[4],Se)/l(be,y(e[4]));p(be,be,t),c(Se,Se,be),h.projectToRenderScreen(Se,Te)}else if(ye[2]<0&&Te[2]<0)continue;ye[2]=0,Te[2]=0;const t=v(x(ye,Te,_e),g);t<S&&(S=t,d(we,Pe),d(Ee,Se),T=e/3)}const w=s.rayBegin,E=s.rayEnd;if(S<4){let e=Number.MAX_VALUE;if(P(x(we,Ee,_e),x(w,E,Re),Ce)){n(Ce,Ce,w);const t=u(Ce);p(Ce,Ce,1/t),e=t/f(w,E)}r(e,Ce,T,!1)}}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return!1;const s=i.get("position");return E(s,null,!1,t)}requiresSlot(e){return 2===e||20===e}createGLMaterial(e){return 0===e.output||4===e.output?new ge(e):null}createBufferWriter(){const e=this.parameters.vertexColors?ee:te;return s(this.parameters.stipplePattern)?new ie(e):new ve(e.clone().vec3f("auxpos1").vec2f("uv0"))}}class ge extends J{updateParameters(e){return this.ensureTechnique(ue,e)}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:e.hasOccludees})}beginSlot(e){return 0===this._output&&this._updateOccludeeState(e),this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}class ve{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,i,s){K(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,i,s),this.writeAuxpos1(e,t,i,s),this.writeUV0(e,t,i,s)}writeAuxpos1(e,t,i,s){const r=i.getField("auxpos1",T),o=t.indices.get("position"),a=t.vertexAttributes.get("position").data,n=e.transformation,l=r.typedBufferStride,p=r.typedBuffer;s*=l;for(let e=0;e<o.length-1;e+=2)for(const t of[1,0]){const i=3*o[e+t],r=a[i],c=a[i+1],d=a[i+2],u=n[0]*r+n[4]*c+n[8]*d+n[12],f=n[1]*r+n[5]*c+n[9]*d+n[13],m=n[2]*r+n[6]*c+n[10]*d+n[14];p[s]=u,p[s+1]=f,p[s+2]=m,s+=l}}writeUV0(e,t,i,s){var r;const o=i.getField("uv0",w),n=t.indices.get("position"),l=t.vertexAttributes.get("position").data,p=null==(r=t.vertexAttributes.get("distanceToStart"))?void 0:r.data,c=e.transformation,u=o.typedBufferStride,h=o.typedBuffer;let g=0;h[s*=u]=0,h[s+1]=g,s+=u;const v=3*n[0],x=a(Pe,l[v],l[v+1],l[v+2]);c&&m(x,x,c);const P=Se,S=n.length-1;let b=1;const C=p?(e,t,i)=>g=p[i]:(e,t,i)=>g+=f(e,t);for(let e=1;e<S;e+=2){const t=3*n[e];a(P,l[t],l[t+1],l[t+2]),c&&m(P,P,c),C(x,P,b++);for(let e=0;e<2;++e)h[s]=1-e,h[s+1]=g,s+=u;d(x,P)}const y=3*n[S];a(P,l[y],l[y+1],l[y+2]),c&&m(P,P,c),C(x,P,b),h[s]=1,h[s+1]=g}}const xe={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleOffColor:null,stipplePreferContinuous:!0,sceneHasOcludees:!1,...Y},Pe=h(),Se=h(),be=h(),Ce=h(),ye=r(),Te=r(),we=h(),Ee=h(),_e=g(),Re=g(),je=h(),Oe=[r(),r(),r(),r()],Le=[h(),h(),h(),h()],Ue=S(),ze=S(),Be=S(),Ae=S();export{he as N};
