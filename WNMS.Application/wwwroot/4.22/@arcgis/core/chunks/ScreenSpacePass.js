/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{i as t,clone as e,b as s,H as i,I as r,J as n,o,k as a}from"../core/lang.js";import{j as h,k as l,n as c,f as d,m as u}from"./mat4.js";import{c as m,b as f,I as _}from"./mat4f64.js";import{f as g}from"./vec2f64.js";import{z as p,U as b,O as y,j as v,h as j,E as x,q as S,m as A,k as M,e as O,b as T,f as R,g as E}from"./mathUtils.js";import{d as N,O as V}from"./vec4f64.js";import{projectPoint as w}from"../geometry/projection.js";import{l as z,y as B}from"./aaBoundingBox.js";import{a as L}from"./aaBoundingRect.js";import{d as P,a as D,r as C}from"../geometry/Polygon.js";import{m as U}from"./dehydratedFeatures.js";import I from"../Graphic.js";import{fromJSON as W}from"../geometry/support/jsonUtils.js";import{d as q,l as k,m as G,n as F,g as Z}from"./sphere.js";import{e as X}from"./mathUtils2.js";import{ad as H,ab as Q,g as J}from"./StencilUtils.js";import{O as K}from"./ArrayPool.js";import{g as Y}from"../core/Accessor.js";import{d as $,g as tt}from"./Util2.js";import{b as et,r as st}from"./utils14.js";import{E as it}from"./Evented.js";import rt from"../core/Handles.js";import{P as nt}from"../core/scheduling.js";import{i as ot}from"./frustum.js";import{w as at}from"./ray.js";import{n as ht}from"./InterleavedLayout.js";class lt{constructor(t,e){this._material=t,this._repository=e,this._map=new Map}destroy(){this._map.forEach(((e,s)=>{t(e)&&this._repository.release(this._material,ct(s))}))}load(e,s){this._map.has(s)||this._map.set(s,this._repository.acquire(this._material,ct(s)));const i=this._map.get(s);if(t(i)){if(2===i.ensureResources(e))return i;this._repository.requestRender()}return null}}function ct(t){switch(t){default:case 0:return 0;case 1:return 7;case 4:case 7:case 6:return 3;case 3:return 2;case 2:return 1;case 5:return 4}}function dt(t){return"declaredClass"in t}function ut(t){return"declaredClass"in t}function mt(t,s){if(!t)return null;if(function(t){return"declaredClass"in t}(t))return t;const i=new I({layer:s,sourceLayer:s});return i.visible=t.visible,i.symbol=e(t.symbol),i.attributes=e(t.attributes),i.geometry=ft(t.geometry),i}function ft(t){return s(t)?null:dt(t)?t:W(function(t){const e=t.spatialReference.toJSON();switch(t.type){case"point":{const{x:s,y:i,z:r,m:n}=t;return{x:s,y:i,z:r,m:n,spatialReference:e}}case"polygon":{const{rings:s,hasZ:i,hasM:r}=t;return{rings:_t(s),hasZ:i,hasM:r,spatialReference:e}}case"polyline":{const{paths:s,hasZ:i,hasM:r}=t;return{paths:_t(s),hasZ:i,hasM:r,spatialReference:e}}case"extent":{const{xmin:s,xmax:i,ymin:r,ymax:n,zmin:o,zmax:a,mmin:h,mmax:l,hasZ:c,hasM:d}=t;return{xmin:s,xmax:i,ymin:r,ymax:n,zmin:o,zmax:a,mmin:h,mmax:l,hasZ:c,hasM:d,spatialReference:e}}case"multipoint":{const{points:s,hasZ:i,hasM:r}=t;return{points:pt(s)?gt(s):s,hasZ:i,hasM:r,spatialReference:e}}default:return}}(t))}function _t(t){return function(t){for(const e of t)if(0!==e.length)return pt(e);return!1}(t)?t.map((t=>gt(t))):t}function gt(t){return t.map((t=>n(t)))}function pt(t){return t.length&&(i(t[0])||r(t[0]))}function bt(t,e){if(!t)return null;let s;if(ut(t)){if(null==e)return t.clone();if(ut(e))return e.copy(t)}return null!=e?(s=e,s.x=t.x,s.y=t.y,s.spatialReference=t.spatialReference,t.hasZ?(s.z=t.z,s.hasZ=t.hasZ):(s.z=null,s.hasZ=!1),t.hasM?(s.m=t.m,s.hasM=!0):(s.m=null,s.hasM=!1)):(s=U(t.x,t.y,t.z,t.spatialReference),t.hasM&&(s.m=t.m,s.hasM=!0)),s}function yt(t,e){if("point"===t.type)return jt(t,e,!1);if(dt(t))switch(t.type){case"extent":return jt(t.center,e,!1);case"polygon":return jt(t.centroid,e,!1);case"polyline":return jt(vt(t),e,!0);case"mesh":return jt(t.origin,e,!1)}else switch(t.type){case"extent":return jt(function(t){const e=isFinite(t.zmin);return U(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),e?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}(t),e,!0);case"polygon":return jt(function(t){const e=t.rings[0];if(!e||0===e.length)return null;const s=C(t.rings,t.hasZ);return U(s[0],s[1],s[2],t.spatialReference)}(t),e,!0);case"polyline":return jt(vt(t),e,!0)}}function vt(t){const e=t.paths[0];if(!e||0===e.length)return null;const s=P(e,D(e)/2);return U(s[0],s[1],s[2],t.spatialReference)}function jt(t,e,s){const i=s?t:bt(t);return e&&t?w(t,i,e)?i:null:i}function xt(t,e,s,i=0){if(t){e||(e=L());const r=t;let n=.5*r.width*(s-1),o=.5*r.height*(s-1);return r.width<1e-7*r.height?n+=o/20:r.height<1e-7*r.width&&(o+=n/20),p(e,r.xmin-n-i,r.ymin-o-i,r.xmax+n+i,r.ymax+o+i),e}return null}function St(t,e){for(let s=0;s<t.geometries.length;++s){const i=t.geometries[s].getMutableAttribute("auxpos1");i&&i.data[3]!==e&&(i.data[3]=e,t.geometryVertexAttrsUpdated(t.geometryRecords[s]))}}function At(e,s){const i=N(V);return t(e)&&(i[0]=e[0],i[1]=e[1],i[2]=e[2]),t(s)?i[3]=s:t(e)&&e.length>3&&(i[3]=e[3]),i}function Mt(e,s,i,r,n,o=[0,0,0,0]){for(let s=0;s<3;++s)t(e)&&null!=e[s]?o[s]=e[s]:t(i)&&null!=i[s]?o[s]=i[s]:o[s]=n[s];return t(s)?o[3]=s:t(r)?o[3]=r:o[3]=n[3],o}function Ot(t=y,e,i,r=1){const n=new Array(3);if(s(e)||s(i))n[0]=1,n[1]=1,n[2]=1;else{let s,r=0;for(let o=2;o>=0;o--){const a=t[o];let h;const l=null!=a,c=0===o&&!s&&!l,d=i[o];"symbol-value"===a||c?h=0!==d?e[o]/d:1:l&&"proportional"!==a&&isFinite(a)&&(h=0!==d?a/d:1),null!=h&&(n[o]=h,s=h,r=Math.max(r,Math.abs(h)))}for(let t=2;t>=0;t--)null==n[t]?n[t]=s:0===n[t]&&(n[t]=.001*r)}for(let t=2;t>=0;t--)n[t]/=r;return b(n)}function Tt(t){return null!=t.isPrimitive&&(t=[t.width,t.depth,t.height]),Rt(t)?null:"Symbol sizes may not be negative values"}function Rt(t){if(Array.isArray(t)){for(const e of t)if(!Rt(e))return!1;return!0}return null==t||t>=0}function Et(t,e,s,i=m()){const r=t||0,n=e||0,o=s||0;return 0!==r&&h(i,i,-r/180*Math.PI),0!==n&&l(i,i,n/180*Math.PI),0!==o&&c(i,i,o/180*Math.PI),i}function Nt(t,e){return null!=e.minDemResolution?e.minDemResolution:z(t)?e.minDemResolutionForPoints:.01*B(t)}const Vt={"bottom-left":g(0,0),bottom:g(.5,0),"bottom-right":g(1,0),left:g(0,.5),center:g(.5,.5),right:g(1,.5),"top-left":g(0,1),top:g(.5,1),"top-right":g(1,1)};class wt{constructor(){this._disposed=!1}get disposed(){return this._disposed}get shaderTransformation(){return this._shaderTransformation}acquire(t,e,s,i,r,n){this.id=Y(),this.geometry=t,this.material=e,this.transformation=s,this.instanceParameters=i,this.origin=r,this._shaderTransformation=n,this._disposed=!1}release(){this._disposed=!1}dispose(){this._disposed=!0}getStaticTransformation(){return this.transformation}getShaderTransformation(){return t(this._shaderTransformation)?this._shaderTransformation(this.transformation):this.transformation}computeAttachmentOrigin(t){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,t):this.geometry.computeAttachmentOrigin(t))&&(v(t,t,this.getStaticTransformation()),!0)}}wt.pool=new K(wt);class zt{constructor(t){this.channel=t,this.id=Y()}}class Bt extends H{constructor(t={}){super(),this.type=1,this._geometryRecords=new Array,this._geometries=new Array,this._objectTransformation=m(),this._bvObjectSpace=new Pt,this._bvWorldSpace=new Pt,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=null==t.castShadow||t.castShadow,this.metadata=t.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new Lt),this.transformation=m();const{geometries:e,materials:s,transformations:i,origins:r}=t;if(Array.isArray(e)){$(s.length===e.length,"Object3D: materials don't match geometries"),$(i.length===e.length,"Object3D: transformations don't match geometries"),this._geometryRecords.length=e.length,this._geometries.length=e.length;for(let t=0;t<e.length;t++)this._geometries[t]=e[t],this._geometryRecords[t]=wt.pool.acquire(e[t],s[t],f(i[t]),{highlights:null,occludees:null,visible:this._visible},r&&r[t])}}get geometryRecords(){return this._geometryRecords}get geometries(){return this._geometries}get transformation(){return this._objectTransformation}set transformation(t){d(this._objectTransformation,t),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}dispose(){this._geometryRecords.length=0,this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(t){$(null==this._parentLayer||null==t,"Object3D can only be added to a single Layer"),this._parentLayer=t}addGeometry(e,s,i,r,n){i=i||_,this._geometries.push(e);const o=wt.pool.acquire(e,s,i,{highlights:null,occludees:null,visible:this._visible},r,n);return this._geometryRecords.push(o),this._hasVolatileTransformation=this._hasVolatileTransformation||t(o.shaderTransformation),this._emit("objectGeometryAdded",{object:this,record:o}),this._invalidateBoundingVolume(),o}removeGeometry(e){const s=this._geometryRecords.splice(e,1)[0];return this._hasVolatileTransformation=t(s.shaderTransformation)?this._geometryRecords.some((e=>t(e.shaderTransformation))):this._hasVolatileTransformation,s.dispose(),this._geometries.splice(e,1),this._emit("objectGeometryRemoved",{object:this,record:s}),this._invalidateBoundingVolume(),s}removeAllGeometries(){for(;this.geometryRecords.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(t){this._emit("vertexAttrsUpdated",{object:this,record:t}),this._invalidateBoundingVolume()}get isVisible(){return this._visible}setVisible(t){if(this._visible!==t){this._visible=t;for(const t of this._geometryRecords)t.instanceParameters.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const t=new zt(1);for(const e of this._geometryRecords)e.instanceParameters.occludees=et(e.instanceParameters.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const e of this._geometryRecords)e.instanceParameters.occludees=st(e.instanceParameters.occludees,t);this._emit("occlusionChanged",this)}highlight(){const t=new zt(0);for(const e of this._geometryRecords)e.instanceParameters.highlights=et(e.instanceParameters.highlights,t);return this._emit("highlightChanged",this),t}removeHighlight(t){for(const e of this._geometryRecords)e.instanceParameters.highlights=st(e.instanceParameters.highlights,t);this._emit("highlightChanged",this)}getCombinedStaticTransformation(t,e){return u(o(e,m()),this.transformation,t.getStaticTransformation())}getCombinedShaderTransformation(t,e){return e=e||m(),u(e,this.transformation,t.getShaderTransformation()),e}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._validateBoundingVolume(),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._validateBoundingVolume(),this._bvObjectSpace}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(let e=0;e<this._geometryRecords.length;++e){const s=this._geometries[e],i=this._geometryRecords[e],r=s.boundingInfo;t(r)&&(this._calculateTransformedBoundingVolume(r,this._bvObjectSpace,i.getShaderTransformation()),this._calculateTransformedBoundingVolume(r,this._bvWorldSpace,this.getCombinedShaderTransformation(i)))}j(this._bvObjectSpace.bounds,this._bvObjectSpace.min,this._bvObjectSpace.max,.5),j(this._bvWorldSpace.bounds,this._bvWorldSpace.min,this._bvWorldSpace.max,.5);const e=T(),i=T(),r=X(this.transformation);for(let t=0;t<this._geometryRecords.length;++t){const n=this._geometries[t].boundingInfo;if(s(n))continue;const o=this._geometryRecords[t].getShaderTransformation(),a=X(o);v(e,n.getCenter(),o);const h=x(e,this._bvObjectSpace.bounds),l=n.getBSRadius()*a;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],h+l),v(i,e,this.transformation);const c=x(i,this._bvWorldSpace.bounds),d=l*r;this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],c+d)}this._bvDirty=!1}_calculateTransformedBoundingVolume(t,e,s){const i=t.getBBMin(),r=t.getBBMax(),n=S(i),o=S(r);v(n,n,s),v(o,o,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],n[t],o[t]),e.max[t]=Math.max(e.max[t],n[t],o[t]);for(let t=0;t<3;++t){A(n,i),A(o,r),n[t]=r[t],o[t]=i[t],v(n,n,s),v(o,o,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],n[t],o[t]),e.max[t]=Math.max(e.max[t],n[t],o[t])}}_invalidateBoundingVolume(){this._bvDirty=!0,t(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(e,s){t(this._parentLayer)&&this._parentLayer.events.emit(e,s)}get test(){const t=this;return{hasGeometry:e=>t._geometries.indexOf(e)>-1,getGeometryIndex:e=>t._geometries.indexOf(e)}}}class Lt{constructor(){this.min=M(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=M(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class Pt extends Lt{constructor(){super(...arguments),this.bounds=q()}init(){O(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),O(this.max,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),k(this.bounds)}}const Dt=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","vertexAttrsUpdated"];class Ct{constructor(t,e){this._objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new Ut,this._objectCount=0,e&&(void 0!==e.maximumObjectsPerNode&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),void 0!==e.maximumDepth&&(this._maximumDepth=e.maximumDepth))}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),Ut.clearPool(),Qt[0]=null,te.prune(),oe.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const s=Ut.acquire();for(let i=0;i<e;i++){const e=t[i];this._isDegenerate(e)?this._degenerateObjects.add(e):(s.init(this._root),this._add(e,s))}Ut.release(s)}remove(e,s=null){this._objectCount-=e.length;const i=Ut.acquire();for(const r of e){const e=t(s)?s:G(this._objectToBoundingSphere(r),ee);Ft(e[3])?(i.init(this._root),this._remove(r,e,i)):this._degenerateObjects.delete(r)}Ut.release(i),this._shrink()}update(t,e){if(!Ft(e[3])&&this._isDegenerate(t))return;const s=function(t){return Qt[0]=t,Qt}(t);this.remove(s,e),this.add(s)}forEachAlongRay(t,e,s){const i=at(t,e);this._forEachNode(this._root,(t=>{if(!this._intersectsNode(i,t))return!1;const e=t.node;return e.terminals.forAll((t=>{this._intersectsObject(i,t)&&s(t)})),null!==e.residents&&e.residents.forAll((t=>{this._intersectsObject(i,t)&&s(t)})),!0}))}forEachAlongRayWithVerticalOffset(t,e,s,i){const r=at(t,e);this._forEachNode(this._root,(t=>{if(!this._intersectsNodeWithOffset(r,t,i))return!1;const e=t.node;return e.terminals.forAll((t=>{this._intersectsObjectWithOffset(r,t,i)&&s(t)})),null!==e.residents&&e.residents.forAll((t=>{this._intersectsObjectWithOffset(r,t,i)&&s(t)})),!0}))}forEach(t){this._forEachNode(this._root,(e=>{const s=e.node;return s.terminals.forAll(t),null!==s.residents&&s.residents.forAll(t),!0})),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,s,i=(()=>!0),r=1/0){let n=1/0,o=1/0,a=null;const h=kt(t,e),l=h=>{if(--r,!i(h))return;const l=this._objectToBoundingSphere(h);if(!ot(s,l))return;const c=Gt(t,e,Z(l)),d=c-l[3],u=c+l[3];d<n&&(n=d,o=u,a=h)};return this._forEachNodeDepthOrdered(this._root,(i=>{if(r<=0||!ot(s,i.bounds))return!1;R(Kt,h,i.halfSize),E(Kt,Kt,i.bounds);if(Gt(t,e,Kt)>o)return!1;const n=i.node;return n.terminals.forAll((t=>l(t))),null!==n.residents&&n.residents.forAll((t=>l(t))),!0}),t,e),a}forEachInDepthRange(t,e,s,i,r,n,o){let a=-1/0,h=1/0;const l={setRange:t=>{1===s?(a=Math.max(a,t.near),h=Math.min(h,t.far)):(a=Math.max(a,-t.far),h=Math.min(h,-t.near))}};l.setRange(i);const c=Gt(e,s,t),d=kt(e,s),u=kt(e,-s),m=t=>{if(!o(t))return;const i=this._objectToBoundingSphere(t),d=Z(i),u=Gt(e,s,d)-c,m=u-i[3],f=u+i[3];m>h||f<a||!ot(n,i)||r(t,l)};this._forEachNodeDepthOrdered(this._root,(t=>{if(!ot(n,t.bounds))return!1;R(Kt,d,t.halfSize),E(Kt,Kt,t.bounds);if(Gt(e,s,Kt)-c>h)return!1;R(Kt,u,t.halfSize),E(Kt,Kt,t.bounds);if(Gt(e,s,Kt)-c<a)return!1;const i=t.node;return i.terminals.forAll((t=>m(t))),null!==i.residents&&i.residents.forAll((t=>m(t))),!0}),e,s)}forEachNode(t){this._forEachNode(this._root,(e=>t(e.node,e.bounds,e.halfSize)))}_intersectsNode(t,e){return Wt(e.bounds,2*-e.halfSize,Yt),Wt(e.bounds,2*e.halfSize,$t),tt(t.origin,t.direction,Yt,$t)}_intersectsNodeWithOffset(t,e,s){return Wt(e.bounds,2*-e.halfSize,Yt),Wt(e.bounds,2*e.halfSize,$t),s.applyToMinMax(Yt,$t),tt(t.origin,t.direction,Yt,$t)}_intersectsObject(t,e){const s=this._objectToBoundingSphere(e);return!(s[3]>0)||F(s,t)}_intersectsObjectWithOffset(t,e,s){const i=this._objectToBoundingSphere(e);return!(i[3]>0)||F(s.applyToBoundingSphere(i),t)}_forEachNode(t,e){let s=Ut.acquire().init(t);const i=[s];for(;0!==i.length;){if(s=i.pop(),e(s)&&!s.isLeaf())for(let t=0;t<s.node.children.length;t++){s.node.children[t]&&i.push(Ut.acquire().init(s).advance(t))}Ut.release(s)}}_forEachNodeDepthOrdered(t,e,s,i=1){let r=Ut.acquire().init(t);const n=[r];for(!function(t,e,s){if(!oe.length)for(let t=0;t<8;++t)oe.push({index:0,distance:0});for(let s=0;s<8;++s){const i=Zt[s];oe.data[s].index=s,oe.data[s].distance=Gt(t,e,i)}oe.sort(((t,e)=>t.distance-e.distance));for(let t=0;t<8;++t)s[t]=oe.data[t].index}(s,i,ae);0!==n.length;){if(r=n.pop(),e(r)&&!r.isLeaf())for(let t=7;t>=0;--t){const e=ae[t];r.node.children[e]&&n.push(Ut.acquire().init(r).advance(e))}Ut.release(r)}}_remove(t,e,s){te.clear();const i=s.advanceTo(e,((t,e)=>{te.push(t.node),te.push(e)}))?s.node.terminals:s.node.residents;if(i.removeUnordered(t),0===i.length)for(let t=te.length-2;t>=0;t-=2){const e=te.data[t],s=te.data[t+1];if(!this._purge(e,s))break}}_nodeIsEmpty(t){if(0!==t.terminals.length)return!1;if(null!==t.residents)return 0===t.residents.length;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(null===t.residents&&(t.residents=new nt({shrink:!0})),!0)}_add(t,e){e.advanceTo(this._objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let s=0;s<e.length;s++){const i=Ut.acquire().init(t);this._add(e.getItemAt(s),i),Ut.release(i)}}_grow(t,e){if(0!==e&&(qt(t,e,(t=>this._objectToBoundingSphere(t)),se),Ft(se[3])&&!this._fitsInsideTree(se)))if(this._nodeIsEmpty(this._root.node))G(se,this._root.bounds),this._root.halfSize=1.25*se[3];else{const t=this._rootBoundsForRootAsSubNode(se);this._placingRootViolatesMaxDepth(t)?this._rebuildTree(se,t):this._growRootAsSubNode(t),Ut.release(t)}}_rebuildTree(t,e){A(ie,e.bounds),ie[3]=e.halfSize,qt([t,ie],2,(t=>t),re);const s=Ut.acquire().init(this._root);this._root.initFrom(null,re,1.25*re[3]),this._forEachNode(s,(t=>(this.add(t.node.terminals.data,t.node.terminals.length),null!==t.node.residents&&this.add(t.node.residents.data,t.node.residents.length),!0))),Ut.release(s)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let s=0;return this._forEachNode(this._root,(t=>(s=Math.max(s,t.depth),s+e<=this._maximumDepth))),s+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],s=t;let i=-1/0;const r=this._root.bounds,n=this._root.halfSize;for(let t=0;t<3;t++){const o=r[t]-n-(s[t]-e),a=s[t]+e-(r[t]+n),h=Math.max(0,Math.ceil(o/(2*n))),l=Math.max(0,Math.ceil(a/(2*n)))+1,c=2**Math.ceil(Math.log(h+l)*Math.LOG2E);i=Math.max(i,c),ne[t].min=h,ne[t].max=l}for(let t=0;t<3;t++){let e=ne[t].min,s=ne[t].max;const o=(i-(e+s))/2;e+=Math.ceil(o),s+=Math.floor(o);const a=r[t]-n-e*n*2;Jt[t]=a+(s+e)*n}return Jt[3]=i*n*Ht,Ut.acquire().initFrom(null,Jt,i*n,0)}_growRootAsSubNode(t){const e=this._root.node;A(se,this._root.bounds),se[3]=this._root.halfSize,this._root.init(t),t.advanceTo(se,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(-1===t)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let s=0,i=0;for(;i<e.length&&null==t;)s=i++,t=e[s];for(;i<e.length;)if(e[i++])return-1;return s}_isDegenerate(t){return!Ft(this._objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,s=this._root.halfSize;return t[3]<=s&&t[0]>=e[0]-s&&t[0]<=e[0]+s&&t[1]>=e[1]-s&&t[1]<=e[1]+s&&t[2]>=e[2]-s&&t[2]<=e[2]+s}}class Ut{constructor(){this.bounds=q(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(e,s,i,r=this.depth){return this.node=t(e)?e:Ut.createEmptyNode(),t(s)&&G(s,this.bounds),this.halfSize=i,this.depth=r,this}advance(t){let e=this.node.children[t];e||(e=Ut.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const s=Zt[t];return this.bounds[0]+=s[0]*this.halfSize,this.bounds[1]+=s[1]*this.halfSize,this.bounds[2]+=s[2]*this.halfSize,this.bounds[3]=this.halfSize*Ht,this}advanceTo(t,e,s=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!s)return e&&e(this,-1),!1;this.node.residents=null}const i=this._childIndex(t);e&&e(this,i),this.advance(i)}}isLeaf(){return null!=this.node.residents}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new nt({shrink:!0}),residents:new nt({shrink:!0})}}static acquire(){return Ut._pool.acquire()}static release(t){Ut._pool.release(t)}static clearPool(){Ut._pool.prune()}}function It(t,e){t[0]=Math.max(t[0],e[0]+e[3]),t[1]=Math.max(t[1],e[1]+e[3]),t[2]=Math.max(t[2],e[2]+e[3])}function Wt(t,e,s){s[0]=t[0]+e,s[1]=t[1]+e,s[2]=t[2]+e}function qt(t,e,s,i){if(1===e){const e=s(t[0]);G(e,i)}else{Yt[0]=1/0,Yt[1]=1/0,Yt[2]=1/0,$t[0]=-1/0,$t[1]=-1/0,$t[2]=-1/0;for(let i=0;i<e;i++){const e=s(t[i]);Ft(e[3])&&(n=e,(r=Yt)[0]=Math.min(r[0],n[0]-n[3]),r[1]=Math.min(r[1],n[1]-n[3]),r[2]=Math.min(r[2],n[2]-n[3]),It($t,e))}j(i,Yt,$t,.5),i[3]=Math.max($t[0]-Yt[0],$t[1]-Yt[1],$t[2]-Yt[2])/2}var r,n}function kt(t,e){let s=1/0,i=null;for(let r=0;r<8;++r){const n=Gt(t,e,Xt[r]);n<s&&(s=n,i=Xt[r])}return i}function Gt(t,e,s){return e*(t[0]*s[0]+t[1]*s[1]+t[2]*s[2])}function Ft(t){return!isNaN(t)&&t!==-1/0&&t!==1/0&&t>0}Ut._pool=new K(Ut);const Zt=[M(-1,-1,-1),M(1,-1,-1),M(-1,1,-1),M(1,1,-1),M(-1,-1,1),M(1,-1,1),M(-1,1,1),M(1,1,1)],Xt=[M(-1,-1,-1),M(-1,-1,1),M(-1,1,-1),M(-1,1,1),M(1,-1,-1),M(1,-1,1),M(1,1,-1),M(1,1,1)],Ht=Math.sqrt(3),Qt=[null];const Jt=q(),Kt=T(),Yt=T(),$t=T(),te=new nt,ee=q(),se=q(),ie=q(),re=q(),ne=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],oe=new nt,ae=[0,0,0,0,0,0,0,0];class he extends H{constructor(t,e=""){var s,i,r;super(),this.apiLayerUid=e,this.type=0,this.events=new it,this.isSliceable=!1,this._objects=new nt,this._stageHandles=new rt,this.apiLayerUid=e,this.isVisible=null==(s=null==t?void 0:t.isVisible)||s,this.isPickable=null==(i=null==t?void 0:t.isPickable)||i,this.updatePolicy=null!=(r=null==t?void 0:t.updatePolicy)?r:0}get objects(){return this._objects}destroy(){this.detachStage(),this._stage=null}attachStage(t){this.detachStage(),this._stage=t;for(const e of Dt)this._stageHandles.add(this.events.on(e,(s=>t.handleEvent(e,s))))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),t(this._octree)&&this._octree.add([e])}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),t(this._octree)&&this._octree.remove([e]))}addMany(e){this._objects.pushArray(e);for(const t of e)t.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),t(this._octree)&&this._octree.add(e)}removeMany(e){const s=new Array;if(this._objects.removeUnorderedMany(e,e.length,s),0!==s.length){for(const t of s)t.parentLayer=null;this.events.emit("layerObjectsRemoved",{layer:this,objects:s}),t(this._octree)&&this._octree.remove(s)}}sync(){t(this._stage)&&1!==this.updatePolicy&&this._stage.syncLayer(this.id)}notifyObjectBBChanged(e,s){t(this._octree)&&this._octree.update(e,s)}getSpatialQueryAccelerator(){return s(this._octree)&&this._objects.length>50&&this._createOctree(),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=a(this._octree)}_createOctree(){this._octree=new Ct((t=>t.boundingVolumeWorldSpace.bounds)),this._octree.add(this._objects.data,this._objects.length)}}function le(e){return t(e)&&0===e.type}const ce=ht().vec3f("position"),de=ht().vec3f("position").vec2f("uv0"),ue=ht().vec3f("position").vec4u8("color");class me{constructor(t){this.vertexBufferLayout=t}allocate(t){return this.vertexBufferLayout.createBuffer(t)}elementCount(t){return t.indices.get("position").length}write(t,e,s,i){Q(e,this.vertexBufferLayout,t.transformation,t.invTranspTransformation,s,i)}}function fe(t){t.attributes.add("position","vec2"),t.varyings.add("uv","vec2"),t.vertex.code.add(J`
    void main(void) {
      gl_Position = vec4(position, 0.0, 1.0);
      uv = position * 0.5 + vec2(0.5);
    }
  `)}export{me as D,wt as G,Bt as O,de as P,fe as S,he as W,lt as a,zt as b,yt as c,Nt as d,Ct as e,Ot as f,Et as g,mt as h,le as i,Rt as j,ft as k,ue as l,At as m,Vt as n,ct as o,ce as p,bt as q,xt as r,Mt as s,St as u,Tt as v};
