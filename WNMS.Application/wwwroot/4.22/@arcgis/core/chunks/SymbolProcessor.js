/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{b as t}from"./shapingUtils.js";import"../core/Error.js";import{h as r,l as s,b as i,i as o,X as a,u as l}from"../core/lang.js";import{L as n}from"./Logger.js";import{isAbortError as m,throwIfAborted as p,all as c}from"../core/promiseUtils.js";import"./ensureType.js";import"../core/accessorSupport/decorators/property.js";import{subclass as u}from"../core/accessorSupport/decorators/subclass.js";import{d,h}from"./diffUtils.js";import f from"../geometry/SpatialReference.js";import{i as j}from"./visualVariablesUtils.js";import{a as y,c as g,b as _,M as b,d as S}from"./Matcher.js";import{B as U}from"./BaseProcessor.js";import"./Rect.js";import"./mat2d.js";import"./mat2df32.js";import"./vec2.js";import"./vec2f32.js";import"./number2.js";import"./object.js";import"../config.js";import"./string.js";import"./metadata.js";import"./handleUtils.js";import"../core/Accessor.js";import"./deprecate.js";import"./ArrayPool.js";import"../core/scheduling.js";import"./nextTick.js";import"../core/Collection.js";import"./Evented.js";import"./shared.js";import"./JSONSupport.js";import"./writer.js";import"./screenUtils.js";import"./definitions.js";import"./enums.js";import"./visualVariablesUtils2.js";import"./Utils13.js";import"./mathUtils.js";import"./common.js";import"./Texture.js";import"./TileStrategy.js";import"./QueueProcessor.js";import"./Queue.js";import"./aaBoundingRect.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./reader.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"./Ellipsoid.js";import"./TileInfoView.js";import"./TileKey.js";import"./tileUtils2.js";import"../rest/support/Query.js";import"../geometry.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"./jsonMap.js";import"../geometry/support/jsonUtils.js";import"../TimeExtent.js";import"./timeUtils.js";import"./enumeration.js";import"./DataLayerSource.js";import"../layers/support/Field.js";import"./domains.js";import"../layers/support/CodedValueDomain.js";import"../layers/support/Domain.js";import"../layers/support/InheritedDomain.js";import"../layers/support/RangeDomain.js";import"./fieldType.js";import"../rest/support/StatisticDefinition.js";import"./TileClipper.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./GeometryUtils2.js";import"./MaterialKey.js";import"./featureConversionUtils.js";import"./OptimizedFeature.js";import"./OptimizedFeatureSet.js";import"./CIMSymbolHelper.js";import"../Color.js";import"./colorUtils.js";import"./floatRGBA.js";import"./utils5.js";import"./GeometryUtils.js";import"./cimAnalyzer.js";import"./arcadeOnDemand.js";import"./callExpressionWithFeature.js";import"./quantizationUtils.js";import"./defaultsJSON.js";import"./earcut.js";import"./TurboLine.js";import"./cimSymbolUtils.js";import"./devEnvironmentUtils.js";import"../portal/Portal.js";import"./Loadable.js";import"./Promise.js";import"./locale.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"../portal/PortalGroup.js";import"./persistableUrlUtils.js";import"./styleUtils.js";import"./LRUCache.js";import"./MemCache.js";import"../core/HandleOwner.js";import"../core/Handles.js";import"./reactiveUtils.js";import"../core/watchUtils.js";class M{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map}destroy(){}async fetchResource(e,t){const r=this._resourceMap,s=r.get(e);if(s)return s;let i=this._inFlightResourceMap.get(e);if(i)return i;try{i=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...t}),this._inFlightResourceMap.set(e,i),i.then((t=>(this._inFlightResourceMap.delete(e),r.set(e,t),t)))}catch(e){return m(e)?null:{width:0,height:0}}return i}getResource(e){var t;return null!=(t=this._resourceMap.get(e))?t:null}}function v(e,t){return(!e.minScale||e.minScale>=t)&&(!e.maxScale||e.maxScale<=t)}function w(e){const t=e.message,r={message:{data:{},tileKey:t.tileKey,tileKeyOrigin:t.tileKeyOrigin},transferList:new Array};for(const e in t.data){const i=t.data[e];if(r.message.data[e]=null,o(i)){const t=i.stride,o=i.indices.slice(0),a=i.vertices.slice(0),l=i.records.slice(0),n={stride:t,indices:o,vertices:a,records:l,metrics:s(i.metrics,(e=>e.slice(0)))};r.transferList.push(o,a,l),r.message.data[e]=n}}return r}n.getLogger("esri.views.2d.layers.features.processors.SymbolProcessor");let I=class extends U{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new M(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(e){this._bufferIds.forEach((t=>{t.forEach(e)}))}async update(e,t){const s=t.schema.processors[0];if("symbol"!==s.type)return;const i=d(this._schema,s);h(i,"mesh")&&(r("esri-2d-update-debug")&&console.debug("Applying Update - Processor:",i),e.mesh=!0,e.why.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(e,t,r,s){return p(s),this._onTileData(e,t,r,s)}onTileClear(e){return this._bufferData.delete(e.key.id),this._bufferIds.delete(e.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:{clear:!0}})}onTileError(e,t,r){const s=r.signal,i={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:s})}onTileUpdate(e){for(const t of e.removed)this._bufferData.has(t.key.id)&&this._bufferData.delete(t.key.id),this._bufferIds.has(t.key.id)&&this._bufferIds.delete(t.key.id);for(const t of e.added)this._bufferData.forEach((e=>{for(const r of e)r.message.tileKey===t.id&&this._updateTileMesh("append",t,w(r),[],!1,!1,null)}))}_addBufferData(e,t){this._bufferData.has(e)||this._bufferData.set(e,[]),this._bufferData.get(e).push(w(t))}_createFactory(e){const{geometryType:t,objectIdField:r,fields:i}=this.service,o={geometryType:t,fields:i,spatialReference:f.fromJSON(this.spatialReference)},a=new y(((e,t)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",e,t)),this.tileStore.tileScheme.tileInfo),{matcher:l,aggregateMatcher:n}=e.mesh;return this._store=a,this._matchers.feature=g(l,a,o,this._resourceManagerProxy),this._matchers.aggregate=s(n,(e=>g(e,a,o,this._resourceManagerProxy))),new _(t,r,a)}async _onTileData(e,t,r,s){p(s);const{type:a,addOrUpdate:l,remove:n}=t,m=t.end,u=!!this._schema.mesh.sortKey;if(!l){const t={type:a,addOrUpdate:null,remove:n,clear:!1,end:m,sort:u};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},s)}const d=this._processFeatures(e,l,r,s);try{const r=await d;if(i(r)){const t={type:a,addOrUpdate:null,remove:n,clear:!1,end:m,sort:u};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},s)}const l=[];for(const t of r){let r=!1;const s=t.message.bufferIds,i=e.key.id,a=t.message.tileKey;if(i!==a&&o(s)){if(!this.tileStore.get(a)){this._addBufferData(i,t),l.push(t);continue}let e=this._bufferIds.get(a);e||(e=new Set,this._bufferIds.set(a,e));const o=Array.from(s);for(const t of o){if(e.has(t)){r=!0;break}e.add(t)}}r||(this._addBufferData(i,t),l.push(t))}await c(l.map((r=>{const i=e.key.id===r.message.tileKey,o=i?t.remove:[],l=i&&t.end;return this._updateTileMesh(a,e,r,o,l,t.clear,s.signal)})))}catch(t){this._handleError(e,t,s)}}async _updateTileMesh(e,t,r,i,o,a,n){const m=e,c=r.message.tileKey,u=!!this._schema.mesh.sortKey;c!==t.key.id&&(o=!1);const d=s(r,(e=>e.message)),h=s(r,(e=>e.transferList))||[],f={type:m,addOrUpdate:d,remove:i,clear:!1,end:o,sort:u},j={transferList:l(h)||[],signal:n};return p(j),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:c,data:f},j)}async _processFeatures(e,t,r,s){if(i(t)||!t.hasFeatures)return null;const o={transform:e.transform,hasZ:!1,hasM:!1},a=this._factory,l={viewingMode:"",scale:e.scale},n=await this._matchers.feature,m=await this._matchers.aggregate;p(s);const c=this._getLabelInfos(e,t);return await a.analyze(t.getCursor(),this._resourceManagerProxy,n,m,o,l),p(s),this._writeFeatureSet(e,t,o,c,a,r)}_writeFeatureSet(e,t,r,s,i,a){const l=t.getSize(),n=new b(e.key.id,{features:l,records:l,metrics:0},this._schema.mesh.matcher.stride,a,!0),m={viewingMode:"",scale:e.scale},p=t.getCursor();for(;p.next();)try{const t=p.getDisplayId(),a=o(s)?s.get(t):null;i.writeCursor(n,p,r,m,e.level,a)}catch(e){}const c=e.tileInfoView.tileInfo.isWrappable;return n.serialize(c)}_handleError(e,t,r){if(!m(t)){const s={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:r.signal})}}_getLabelingSchemaForScale(e){const t=this._schema.mesh.labels;if(i(t))return null;if("subtype"===t.type){const r={type:"subtype",classes:{}};let s=!1;for(const i in t.classes){const o=t.classes[i].filter((t=>v(t,e.scale)));s=s||!!o.length,r.classes[i]=o}return s?r:null}const r=t.classes.filter((t=>v(t,e.scale)));return r.length?{type:"simple",classes:r}:null}_getLabels(e,t){if("subtype"===t.type){var r;const s=this.service.subtypeField,i=a(s,"Expected to find subtype Field"),o=e.readAttribute(i);return null==o?[]:null!=(r=t.classes[o])?r:[]}return t.classes}_getLabelInfos(e,r){const s=this._getLabelingSchemaForScale(e);if(i(s))return null;const o=new Map,a=r.getCursor();for(;a.next();){const e=a.getDisplayId(),r=[],i=j(e),l=i&&1!==a.readAttribute("cluster_count")?"aggregate":"feature",n=this._getLabels(a,s);for(const s of n){if(s.target!==l)continue;const o=a.getStorage(),n=i&&"feature"===l?o.getComputedStringAtIndex(a.readAttribute("referenceId"),s.fieldIndex):o.getComputedStringAtIndex(e,s.fieldIndex);if(!n)continue;const m=t(n.toString()),p=m[0],c=m[1];this._store.getMosaicItem(s.symbol,S(p)).then((e=>{r[s.index]={glyphs:e.glyphMosaicItems,rtl:c,index:s.index}}))}o.set(e,r)}return o}};I=e([u("esri.views.2d.layers.features.processors.SymbolProcessor")],I);const T=I;export{T as default};
