/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{i as t,b as r}from"../core/lang.js";import{a as o,b as n,c as e}from"./unitUtils.js";import{c as a}from"./quatf64.js";import{s as i,r as s,t as l,a as c,m as p,e as u,b as f}from"./mat4.js";import{c as g,I as m}from"./mat4f64.js";import{n as h}from"./mat3.js";import{computeTranslationToOriginAndRotation as y,projectBuffer as A}from"../geometry/projection.js";import{b as j,g as d,a as w}from"./projectionEllipsoid.js";import{_ as b}from"./tslib.es6.js";import{a as x}from"./JSONSupport.js";import{property as v}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{subclass as T}from"../core/accessorSupport/decorators/subclass.js";import{b as M,k as F,j as R,p as E,q as N}from"./mathUtils.js";import z from"../geometry/Point.js";import{c as P,b as S,d as _}from"./axisAngleDegrees.js";import{B,a as I}from"./BufferView.js";import{t as L,c as q,a as O}from"./vec3.js";import{c as G,d as Y,e as U,p as k,a as D,b as J,t as V,f as W,g as C}from"./projection.js";var H;let K=H=class extends x{constructor(t){super(t),this.origin=M(),this.translation=M(),this.rotation=P(),this.scale=F(1,1,1),this.geographic=!0}get localMatrix(){const t=g();return i(t,t,this.scale),s(t,t,_(this.rotation),S(this.rotation)),l(t,t,this.translation),t}get localMatrixInverse(){return c(g(),this.localMatrix)}applyLocal(t,r){return R(r,t,this.localMatrix)}applyLocalInverse(t,r){return R(r,t,this.localMatrixInverse)}project(t,r){const o=new Float64Array(t.length),n=B.fromTypedArray(o),e=B.fromTypedArray(t);if(this.geographic){const t=j(d(r)),a=g();return y(r,this.origin,a,t),p(a,a,this.localMatrix),L(n,e,a),A(o,t,0,o,r,0,o.length/3),o}const{localMatrix:a,origin:i}=this;u(a,m)?q(n,e):L(n,e,a);for(let t=0;t<o.length;t+=3)o[t+0]+=i[0],o[t+1]+=i[1],o[t+2]+=i[2];return o}getOriginPoint(t){const[r,o,n]=this.origin;return new z({x:r,y:o,z:n,spatialReference:t})}equals(r){return t(r)&&this.geographic===r.geographic&&E(this.origin,r.origin)&&f(this.localMatrix,r.localMatrix)}clone(){const t={origin:N(this.origin),translation:N(this.translation),rotation:P(this.rotation),scale:N(this.scale),geographic:this.geographic};return new H(t)}};b([v({type:[Number],nonNullable:!0,json:{write:!0}})],K.prototype,"origin",void 0),b([v({type:[Number],nonNullable:!0,json:{write:!0}})],K.prototype,"translation",void 0),b([v({type:[Number],nonNullable:!0,json:{write:!0}})],K.prototype,"rotation",void 0),b([v({type:[Number],nonNullable:!0,json:{write:!0}})],K.prototype,"scale",void 0),b([v({type:Boolean,nonNullable:!0,json:{write:!0}})],K.prototype,"geographic",void 0),b([v()],K.prototype,"localMatrix",null),b([v()],K.prototype,"localMatrixInverse",null),K=H=b([T("esri.geometry.support.MeshTransform")],K);const Q=K;function X(t,r){var o;return t.isGeographic||t.isWebMercator&&(null==(o=null==r?void 0:r.geographic)||o)}function Z(t,o,n){return X(o.spatialReference,n)?function(t,o,n){const e=o.spatialReference,a=at(o,n,st),i=new Float64Array(t.position.length),s=function(t,r,o,n){L(B.fromTypedArray(n),B.fromTypedArray(t),r);const e=new Float64Array(t.length);return G(n,e,o)}(t.position,a,e,i),l=h(ct,a),c=function(t,o,n,e,a){if(r(n))return null;const i=new Float32Array(n.length);return O(I.fromTypedArray(i),I.fromTypedArray(n),e),Y(i,t,o,a,i),i}(s,i,t.normal,l,e),p=function(t,o,n,e,a){if(r(n))return null;const i=new Float32Array(n.length);O(I.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT),I.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),e);for(let t=3;t<i.length;t+=4)i[t]=n[t];return U(i,t,o,a,i),i}(s,i,t.tangent,l,e);return{position:s,normal:c,tangent:p}}(t,o,n):function(t,r,o){const n=new Float64Array(t.position.length),e=t.position,a=r.x,i=r.y,s=r.z||0,{horizontal:l,vertical:c}=it(o?o.unit:null,r.spatialReference);for(let t=0;t<e.length;t+=3)n[t+0]=e[t+0]*l+a,n[t+1]=e[t+1]*l+i,n[t+2]=e[t+2]*c+s;return{position:n,normal:t.normal,tangent:t.tangent}}(t,o,n)}function $(o,n,e){const{position:a,normal:i,tangent:s}=o;if(r(n))return{position:a,normal:i,tangent:s};const l=n.localMatrix;return Z({position:V(a,new Float64Array(a.length),l),normal:t(i)?W(i,new Float32Array(i.length),l):null,tangent:t(s)?C(s,new Float32Array(s.length),l):null},n.getOriginPoint(e),{geographic:n.geographic})}function tt(t,r,o){if(null!=o&&o.useTransform){var n;const{position:e,normal:a,tangent:i}=t;return{vertexAttributes:{position:e,normal:a,tangent:i},transform:new Q({origin:[r.x,r.y,null!=(n=r.z)?n:0],geographic:X(r.spatialReference,o)})}}return{vertexAttributes:Z(t,r,o),transform:null}}function rt(t,r,o){return X(r.spatialReference,o)?et(t,r,o):nt(t,r,o)}function ot(t,o,n,e){if(r(o))return rt(t,n,e);const a=$(t,o,n.spatialReference);return n.equals(o.getOriginPoint(n.spatialReference))?nt(a,n,e):X(n.spatialReference,e)?et(a,n,e):nt(a,n,e)}function nt(t,r,o){const n=new Float64Array(t.position.length),e=t.position,a=r.x,i=r.y,s=r.z||0,{horizontal:l,vertical:c}=it(o?o.unit:null,r.spatialReference);for(let t=0;t<e.length;t+=3)n[t+0]=(e[t+0]-a)/l,n[t+1]=(e[t+1]-i)/l,n[t+2]=(e[t+2]-s)/c;return{position:n,normal:t.normal,tangent:t.tangent}}function et(t,o,n){const e=o.spatialReference;at(o,n,st);const a=c(lt,st),i=new Float64Array(t.position.length),s=function(t,r,o,n){const e=k(t,r,n),a=B.fromTypedArray(e),i=new Float64Array(e.length),s=B.fromTypedArray(i);return L(s,a,o),i}(t.position,e,a,i),l=h(ct,a),p=function(t,o,n,e,a){if(r(t))return null;const i=D(t,o,n,e,new Float32Array(t.length)),s=I.fromTypedArray(i);return O(s,s,a),i}(t.normal,t.position,i,e,l),u=function(t,o,n,e,a){if(r(t))return null;const i=J(t,o,n,e,new Float32Array(t.length)),s=I.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT);return O(s,s,a),i}(t.tangent,t.position,i,e,l);return{position:s,normal:p,tangent:u}}function at(t,r,o){y(t.spatialReference,[t.x,t.y,t.z||0],o,w(t.spatialReference));const{horizontal:n,vertical:e}=it(r?r.unit:null,t.spatialReference);return i(o,o,[n,n,e]),o}function it(t,a){if(r(t))return pt;const i=a.isGeographic?1:o(a),s=a.isGeographic?1:n(a),l=e(1,t,"meters");return{horizontal:l*i,vertical:l*s}}const st=g(),lt=g(),ct=a(),pt={horizontal:1,vertical:1};export{Q as M,tt as a,$ as b,ot as c,Z as g,X as i,rt as u};
